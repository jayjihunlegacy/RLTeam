<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>theano.compile.function_module &mdash; Tetris  documentation</title>
    
    <link rel="stylesheet" href="../../../_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     '',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <link rel="top" title="Tetris  documentation" href="../../../index.html" />
    <link rel="up" title="Module code" href="../../index.html" /> 
  </head>
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">Tetris  documentation</a> &raquo;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" accesskey="U">Module code</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for theano.compile.function_module</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Driver of graph construction, optimization, and linking.</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">absolute_import</span><span class="p">,</span> <span class="n">print_function</span><span class="p">,</span> <span class="n">division</span>

<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">from</span> <span class="nn">six</span> <span class="kn">import</span> <span class="n">string_types</span><span class="p">,</span> <span class="n">iteritems</span><span class="p">,</span> <span class="n">iterkeys</span>
<span class="kn">from</span> <span class="nn">six.moves</span> <span class="kn">import</span> <span class="nb">xrange</span>
<span class="kn">import</span> <span class="nn">six.moves.copyreg</span> <span class="kn">as</span> <span class="nn">copyreg</span>
<span class="kn">import</span> <span class="nn">six.moves.cPickle</span> <span class="kn">as</span> <span class="nn">pickle</span>
<span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">chain</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">import</span> <span class="nn">numpy</span>

<span class="kn">import</span> <span class="nn">theano</span>
<span class="kn">from</span> <span class="nn">theano</span> <span class="kn">import</span> <span class="n">config</span><span class="p">,</span> <span class="n">gof</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">partial</span>
<span class="kn">from</span> <span class="nn">theano.compat</span> <span class="kn">import</span> <span class="n">izip</span>
<span class="kn">from</span> <span class="nn">theano.gof</span> <span class="kn">import</span> <span class="n">graph</span>
<span class="kn">import</span> <span class="nn">theano.compile.mode</span>
<span class="kn">from</span> <span class="nn">theano.compile.io</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">In</span><span class="p">,</span> <span class="n">SymbolicInput</span><span class="p">,</span> <span class="n">SymbolicInputKit</span><span class="p">,</span> <span class="n">SymbolicOutput</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">theano.compile.ops</span> <span class="kn">import</span> <span class="n">deep_copy_op</span><span class="p">,</span> <span class="n">view_op</span>
<span class="kn">from</span> <span class="nn">theano.gof.graph</span> <span class="kn">import</span> <span class="n">is_same_graph</span>
<span class="kn">from</span> <span class="nn">theano.gof.op</span> <span class="kn">import</span> <span class="n">ops_with_inner_function</span>

<span class="kn">import</span> <span class="nn">logging</span>
<span class="n">_logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="s1">&#39;theano.compile.function_module&#39;</span><span class="p">)</span>

<span class="n">__docformat__</span> <span class="o">=</span> <span class="s2">&quot;restructuredtext en&quot;</span>


<span class="k">class</span> <span class="nc">UnusedInputError</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A symbolic input passed to function is not needed.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">pass</span>


<span class="k">def</span> <span class="nf">alias_root</span><span class="p">(</span><span class="n">v</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the variable to which v is aliased by view_maps and destroy_maps.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">v</span><span class="o">.</span><span class="n">owner</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">v</span>
    <span class="n">vmap</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">owner</span><span class="o">.</span><span class="n">op</span><span class="p">,</span> <span class="s1">&#39;view_map&#39;</span><span class="p">,</span> <span class="p">{})</span>
    <span class="n">dmap</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">owner</span><span class="o">.</span><span class="n">op</span><span class="p">,</span> <span class="s1">&#39;destroy_map&#39;</span><span class="p">,</span> <span class="p">{})</span>
    <span class="n">outpos</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">owner</span><span class="o">.</span><span class="n">outputs</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
    <span class="n">v_views</span> <span class="o">=</span> <span class="n">vmap</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">outpos</span><span class="p">,</span> <span class="p">[])</span> <span class="o">+</span> <span class="n">dmap</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">outpos</span><span class="p">,</span> <span class="p">[])</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">v_views</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
            <span class="nb">str</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot; is a view/destroyed version of more then one inputs. &quot;</span>
            <span class="s2">&quot;Currently, we only support the case where an output is a view or &quot;</span>
            <span class="s2">&quot;a destroyed version of one input.&quot;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">v_views</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">alias_root</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">owner</span><span class="o">.</span><span class="n">inputs</span><span class="p">[</span><span class="n">v_views</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">v</span>


<span class="k">def</span> <span class="nf">view_tree_set</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">treeset</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Add to `treeset` all variables that are views of v, given that v is</span>
<span class="sd">    not a view.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">treeset</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">cl</span><span class="p">,</span> <span class="n">v_input_pos_to_cl</span> <span class="ow">in</span> <span class="n">v</span><span class="o">.</span><span class="n">clients</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">cl</span> <span class="o">==</span> <span class="s1">&#39;output&#39;</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="n">vmap</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">cl</span><span class="o">.</span><span class="n">op</span><span class="p">,</span> <span class="s1">&#39;view_map&#39;</span><span class="p">,</span> <span class="p">{})</span>
        <span class="n">dmap</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">cl</span><span class="o">.</span><span class="n">op</span><span class="p">,</span> <span class="s1">&#39;destroy_map&#39;</span><span class="p">,</span> <span class="p">{})</span>
        <span class="k">for</span> <span class="n">opos</span><span class="p">,</span> <span class="n">iposlist</span> <span class="ow">in</span> <span class="n">chain</span><span class="p">(</span><span class="n">iteritems</span><span class="p">(</span><span class="n">vmap</span><span class="p">),</span> <span class="n">iteritems</span><span class="p">(</span><span class="n">dmap</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">v_input_pos_to_cl</span> <span class="ow">in</span> <span class="n">iposlist</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">cl</span><span class="o">.</span><span class="n">outputs</span><span class="p">[</span><span class="n">opos</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">treeset</span><span class="p">:</span>
                    <span class="n">view_tree_set</span><span class="p">(</span><span class="n">cl</span><span class="o">.</span><span class="n">outputs</span><span class="p">[</span><span class="n">opos</span><span class="p">],</span> <span class="n">treeset</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">infer_reuse_pattern</span><span class="p">(</span><span class="n">fgraph</span><span class="p">,</span> <span class="n">outputs_to_disown</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Given an fgraph and a list of variables, returns the list or set</span>
<span class="sd">    of all variables which may share the same underlying data storage</span>
<span class="sd">    as any of the specified variables. Used internally by function,</span>
<span class="sd">    FunctionMaker.</span>

<span class="sd">    This list (or set) is also refered to as no_recycling sometimes,</span>
<span class="sd">    especially by linker code.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">rval</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">outputs_to_disown</span><span class="p">:</span>
        <span class="n">view_tree_set</span><span class="p">(</span><span class="n">alias_root</span><span class="p">(</span><span class="n">o</span><span class="p">),</span> <span class="n">rval</span><span class="p">)</span>
    <span class="c1"># remove from rval all of the inputs, constants, values.</span>
    <span class="n">rval</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">r</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">rval</span> <span class="k">if</span> <span class="n">r</span><span class="o">.</span><span class="n">owner</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">rval</span>


<span class="k">def</span> <span class="nf">fgraph_updated_vars</span><span class="p">(</span><span class="n">fgraph</span><span class="p">,</span> <span class="n">expanded_inputs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Reconstruct the full &quot;updates&quot; dictionary, mapping from FunctionGraph input</span>
<span class="sd">    variables to the fgraph outputs that will replace their values.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    dict variable -&gt; variable</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">updated_vars</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">potential_values</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">fgraph</span><span class="o">.</span><span class="n">outputs</span><span class="p">)</span>  <span class="c1"># copy the list</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">expanded_inputs</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">fgraph</span><span class="o">.</span><span class="n">inputs</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;expanded_inputs must match len(fgraph.inputs)&#39;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">e_input</span><span class="p">,</span> <span class="n">ivar</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">expanded_inputs</span><span class="p">,</span> <span class="n">fgraph</span><span class="o">.</span><span class="n">inputs</span><span class="p">))):</span>
        <span class="k">if</span> <span class="n">e_input</span><span class="o">.</span><span class="n">update</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">updated_vars</span><span class="p">[</span><span class="n">ivar</span><span class="p">]</span> <span class="o">=</span> <span class="n">potential_values</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">updated_vars</span>


<span class="k">class</span> <span class="nc">Supervisor</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Listener for FunctionGraph events which makes sure that no</span>
<span class="sd">    operation overwrites the contents of protected Variables. The</span>
<span class="sd">    outputs of the FunctionGraph are protected by default.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">protected</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">protected</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">protected</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">validate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fgraph</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">fgraph</span><span class="p">,</span> <span class="s1">&#39;destroyers&#39;</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">True</span>
        <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">protected</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">fgraph</span><span class="o">.</span><span class="n">outputs</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">fgraph</span><span class="o">.</span><span class="n">destroyers</span><span class="p">(</span><span class="n">r</span><span class="p">):</span>
                <span class="k">raise</span> <span class="n">gof</span><span class="o">.</span><span class="n">InconsistencyError</span><span class="p">(</span><span class="s2">&quot;Trying to destroy a protected&quot;</span>
                                             <span class="s2">&quot;Variable.&quot;</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">std_fgraph</span><span class="p">(</span><span class="n">input_specs</span><span class="p">,</span> <span class="n">output_specs</span><span class="p">,</span> <span class="n">accept_inplace</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Makes an FunctionGraph corresponding to the input specs and the output</span>
<span class="sd">    specs.  Any SymbolicInput in the input_specs, if its update field</span>
<span class="sd">    is not None, will add an output to the FunctionGraph corresponding to that</span>
<span class="sd">    update. The return value is the FunctionGraph as well as a list of</span>
<span class="sd">    SymbolicOutput instances corresponding to the updates.</span>

<span class="sd">    If accept_inplace is False, the graph will be checked for inplace</span>
<span class="sd">    operations and an exception will be raised if it has any. If</span>
<span class="sd">    accept_inplace is True, a DestroyHandler will be added to the FunctionGraph</span>
<span class="sd">    if there are any inplace operations.</span>

<span class="sd">    The returned FunctionGraph is a clone of the graph between the provided</span>
<span class="sd">    inputs and outputs.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">orig_inputs</span> <span class="o">=</span> <span class="p">[</span><span class="n">spec</span><span class="o">.</span><span class="n">variable</span> <span class="k">for</span> <span class="n">spec</span> <span class="ow">in</span> <span class="n">input_specs</span><span class="p">]</span>

    <span class="c1"># Extract the updates and the mapping between update outputs and</span>
    <span class="c1"># the updated inputs.</span>
    <span class="n">updates</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">update_mapping</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">out_idx</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">output_specs</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">inp_idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">input_specs</span><span class="p">)):</span>
        <span class="k">if</span> <span class="n">input_specs</span><span class="p">[</span><span class="n">inp_idx</span><span class="p">]</span><span class="o">.</span><span class="n">update</span><span class="p">:</span>
            <span class="n">updates</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">input_specs</span><span class="p">[</span><span class="n">inp_idx</span><span class="p">]</span><span class="o">.</span><span class="n">update</span><span class="p">)</span>
            <span class="n">update_mapping</span><span class="p">[</span><span class="n">out_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">inp_idx</span>
            <span class="n">out_idx</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="n">orig_outputs</span> <span class="o">=</span> <span class="p">[</span><span class="n">spec</span><span class="o">.</span><span class="n">variable</span> <span class="k">for</span> <span class="n">spec</span> <span class="ow">in</span> <span class="n">output_specs</span><span class="p">]</span> <span class="o">+</span> <span class="n">updates</span>

    <span class="n">fgraph</span> <span class="o">=</span> <span class="n">gof</span><span class="o">.</span><span class="n">fg</span><span class="o">.</span><span class="n">FunctionGraph</span><span class="p">(</span><span class="n">orig_inputs</span><span class="p">,</span> <span class="n">orig_outputs</span><span class="p">,</span>
                                  <span class="n">update_mapping</span><span class="o">=</span><span class="n">update_mapping</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">fgraph</span><span class="o">.</span><span class="n">apply_nodes</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">op</span><span class="p">,</span> <span class="s1">&#39;destroy_map&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">accept_inplace</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Graph must not contain inplace operations&quot;</span><span class="p">,</span>
                                <span class="n">node</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">op</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">fgraph</span><span class="o">.</span><span class="n">attach_feature</span><span class="p">(</span><span class="n">gof</span><span class="o">.</span><span class="n">DestroyHandler</span><span class="p">())</span>
                <span class="k">break</span>

    <span class="c1"># We need to protect all immutable inputs from inplace operations.</span>
    <span class="n">fgraph</span><span class="o">.</span><span class="n">attach_feature</span><span class="p">(</span>
        <span class="n">Supervisor</span><span class="p">(</span><span class="nb">input</span>
                   <span class="k">for</span> <span class="n">spec</span><span class="p">,</span> <span class="nb">input</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">input_specs</span><span class="p">,</span> <span class="n">fgraph</span><span class="o">.</span><span class="n">inputs</span><span class="p">)</span>
                   <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">spec</span><span class="o">.</span><span class="n">mutable</span> <span class="ow">or</span>
                           <span class="p">(</span><span class="nb">hasattr</span><span class="p">(</span><span class="n">fgraph</span><span class="p">,</span> <span class="s1">&#39;destroyers&#39;</span><span class="p">)</span> <span class="ow">and</span>
                            <span class="n">fgraph</span><span class="o">.</span><span class="n">destroyers</span><span class="p">(</span><span class="nb">input</span><span class="p">)))))</span>

    <span class="c1"># If named nodes are replaced, keep the name</span>
    <span class="k">for</span> <span class="n">feature</span> <span class="ow">in</span> <span class="n">std_fgraph</span><span class="o">.</span><span class="n">features</span><span class="p">:</span>
        <span class="n">fgraph</span><span class="o">.</span><span class="n">attach_feature</span><span class="p">(</span><span class="n">feature</span><span class="p">())</span>
    <span class="k">return</span> <span class="n">fgraph</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">SymbolicOutput</span><span class="p">,</span> <span class="n">updates</span><span class="p">))</span>


<span class="n">std_fgraph</span><span class="o">.</span><span class="n">features</span> <span class="o">=</span> <span class="p">[</span><span class="n">gof</span><span class="o">.</span><span class="n">toolbox</span><span class="o">.</span><span class="n">PreserveVariableAttributes</span><span class="p">]</span>


<span class="k">class</span> <span class="nc">AliasedMemoryError</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Memory is aliased that should not be.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span>


<span class="c1">###</span>
<span class="c1"># Function</span>
<span class="c1">###</span>

<span class="c1"># unique id object used as a placeholder for duplicate entries</span>
<span class="n">DUPLICATE</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;DUPLICATE&#39;</span><span class="p">]</span>


<span class="k">class</span> <span class="nc">Function</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Type of the functions returned by theano.function or</span>
<span class="sd">    theano.FunctionMaker.create.</span>

<span class="sd">    `Function` is the callable object that does computation.  It has the storage</span>
<span class="sd">    of inputs and outputs, performs the packing and unpacking of inputs and</span>
<span class="sd">    return values. It implements the square-bracket indexing so that you can</span>
<span class="sd">    look up the value of a symbolic node.</span>

<span class="sd">    Functions are copyable via {{{fn.copy()}}} and {{{copy.copy(fn)}}}.</span>
<span class="sd">    When a function is copied, this instance is duplicated. Contrast with</span>
<span class="sd">    self.maker (instance of `FunctionMaker`) that is shared between copies.</span>
<span class="sd">    The meaning of copying a function is that the containers and their current</span>
<span class="sd">    values will all be duplicated. This requires that mutable inputs be</span>
<span class="sd">    copied, whereas immutable inputs may be shared between copies.</span>

<span class="sd">    A Function instance is hashable, on the basis of its memory</span>
<span class="sd">    address (its id).</span>

<span class="sd">    A Function instance is only equal to itself.</span>

<span class="sd">    A Function instance may be serialized using the `pickle` or</span>
<span class="sd">    `cPickle` modules.  This will save all default inputs, the graph,</span>
<span class="sd">    and WRITEME to the pickle file.</span>

<span class="sd">    A Function instance have a ``trust_input`` field that default to</span>
<span class="sd">    False. When True, we don&#39;t do extra check of the input to give</span>
<span class="sd">    better error message. In some case, python code will still return</span>
<span class="sd">    the good results if you pass a python or numpy scalar instead of a</span>
<span class="sd">    numpy tensor.  C code should raise an error if you pass an object</span>
<span class="sd">    of the wrong type.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    finder</span>
<span class="sd">    inv_finder</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">pickle_aliased_memory_strategy</span> <span class="o">=</span> <span class="s1">&#39;warn&#39;</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    How to deal with pickling finding aliased storage.</span>

<span class="sd">    Meaningful settings are: &#39;ignore&#39;, &#39;warn&#39;, &#39;raise&#39;.</span>

<span class="sd">    If the value is &#39;warn&#39;, then a message will be printed to stderr</span>
<span class="sd">    if aliased storage is dectected during pickle.dump.</span>

<span class="sd">    If the value is &#39;raise&#39;, then an AliasedMemoryError will be raised</span>
<span class="sd">    if aliased storage is detected during pickle.dump.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">input_storage</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    List of Container instances.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">output_storage</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    List of Container instances.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">indices</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    List of (SymbolicInput|SymbolicInputKit, indices, [SymbolicInput,...]),</span>
<span class="sd">    one tuple for each input.</span>

<span class="sd">    The first tuple element is the SymbolicInput object for the corresponding</span>
<span class="sd">    function input.</span>

<span class="sd">    The second and third tuple elements are used only by Kits, which</span>
<span class="sd">    are deprecated.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">defaults</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    List of 3-tuples, one 3-tuple for each input.</span>

<span class="sd">    Tuple element 0: Bool:  Is this input required at each function call?</span>
<span class="sd">    Tuple element 1: Bool: Should this inputs value be reverted after</span>
<span class="sd">        each call?</span>
<span class="sd">    Tuple element 2: Any:  The value associated with this input.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">unpack_single</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Bool: for outputs lists of length 1, should the 0&#39;th element be</span>
<span class="sd">    returned directly?</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">return_none</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Bool: whether the function should return None or not.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">maker</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    FunctionMaker instance.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">fn</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A function that evaluates the graph. Typically a linker&#39;s make_thunk method</span>
<span class="sd">    created this function.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">finder</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Dictionary mapping several kinds of things to containers.</span>

<span class="sd">    We set an entry in finder for:</span>

<span class="sd">    - the index of the input</span>

<span class="sd">    - the variable instance the input is based on</span>

<span class="sd">    - the name of the input</span>

<span class="sd">    All entries map to the container or to DUPLICATE if an ambiguity</span>
<span class="sd">    is detected.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">inv_finder</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Dict. Reverse lookup of `finder`.</span>

<span class="sd">    It maps container -&gt; SymbolicInput</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fn</span><span class="p">,</span> <span class="n">input_storage</span><span class="p">,</span> <span class="n">output_storage</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">outputs</span><span class="p">,</span>
                 <span class="n">defaults</span><span class="p">,</span> <span class="n">unpack_single</span><span class="p">,</span> <span class="n">return_none</span><span class="p">,</span> <span class="n">output_keys</span><span class="p">,</span> <span class="n">maker</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fn</span> <span class="o">=</span> <span class="n">fn</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">input_storage</span> <span class="o">=</span> <span class="n">input_storage</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">output_storage</span> <span class="o">=</span> <span class="n">output_storage</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">indices</span> <span class="o">=</span> <span class="n">indices</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">outputs</span> <span class="o">=</span> <span class="n">outputs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">defaults</span> <span class="o">=</span> <span class="n">defaults</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">unpack_single</span> <span class="o">=</span> <span class="n">unpack_single</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">return_none</span> <span class="o">=</span> <span class="n">return_none</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">maker</span> <span class="o">=</span> <span class="n">maker</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">profile</span> <span class="o">=</span> <span class="bp">None</span>  <span class="c1"># reassigned in FunctionMaker.create</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">trust_input</span> <span class="o">=</span> <span class="bp">False</span>  <span class="c1"># If True, we don&#39;t check the input parameter</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nodes_with_inner_function</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">output_keys</span> <span class="o">=</span> <span class="n">output_keys</span>

        <span class="c1"># We will be popping stuff off this `containers` object.  It is a copy.</span>
        <span class="n">containers</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">input_storage</span><span class="p">)</span>
        <span class="n">finder</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">inv_finder</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">def</span> <span class="nf">distribute</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="n">cs</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
            <span class="nb">input</span><span class="o">.</span><span class="n">distribute</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">cs</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">cs</span><span class="p">:</span>
                <span class="n">c</span><span class="o">.</span><span class="n">provided</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="c1"># Store the list of names of named inputs.</span>
        <span class="n">named_inputs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># Count the number of un-named inputs.</span>
        <span class="n">n_unnamed_inputs</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># Initialize the storage</span>
        <span class="c1"># this loop works by modifying the elements (as variable c) of</span>
        <span class="c1"># self.input_storage inplace.</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">((</span><span class="nb">input</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">sinputs</span><span class="p">),</span> <span class="p">(</span><span class="n">required</span><span class="p">,</span> <span class="n">refeed</span><span class="p">,</span> <span class="n">value</span><span class="p">))</span> <span class="ow">in</span> \
                <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">indices</span><span class="p">,</span> <span class="n">defaults</span><span class="p">)):</span>
            <span class="c1"># this is true iff input is not a SymbolicInputKit</span>
            <span class="k">if</span> <span class="n">indices</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="c1"># containers is being used as a stack. Here we pop off</span>
                <span class="c1"># the next one.</span>
                <span class="n">c</span> <span class="o">=</span> <span class="n">containers</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">c</span><span class="o">.</span><span class="n">strict</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="s1">&#39;strict&#39;</span><span class="p">,</span> <span class="bp">False</span><span class="p">)</span>
                <span class="n">c</span><span class="o">.</span><span class="n">allow_downcast</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="s1">&#39;allow_downcast&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="c1"># Always initialize the storage.</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">gof</span><span class="o">.</span><span class="n">Container</span><span class="p">):</span>
                        <span class="c1"># There is no point in obtaining the current value</span>
                        <span class="c1"># stored in the container, since the container is</span>
                        <span class="c1"># shared.</span>
                        <span class="c1"># For safety, we make sure &#39;refeed&#39; is False, since</span>
                        <span class="c1"># there is no need to refeed the defaullt value.</span>
                        <span class="k">assert</span> <span class="ow">not</span> <span class="n">refeed</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">c</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span>
                <span class="n">c</span><span class="o">.</span><span class="n">required</span> <span class="o">=</span> <span class="n">required</span>
                <span class="n">c</span><span class="o">.</span><span class="n">implicit</span> <span class="o">=</span> <span class="nb">input</span><span class="o">.</span><span class="n">implicit</span>
                <span class="c1"># this is a count of how many times the input has been</span>
                <span class="c1"># provided (reinitialized to 0 on __call__)</span>
                <span class="n">c</span><span class="o">.</span><span class="n">provided</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">finder</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">c</span>
                <span class="n">finder</span><span class="p">[</span><span class="nb">input</span><span class="o">.</span><span class="n">variable</span><span class="p">]</span> <span class="o">=</span> <span class="n">c</span>
                <span class="k">if</span> <span class="nb">input</span><span class="o">.</span><span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">finder</span><span class="p">:</span>
                    <span class="n">finder</span><span class="p">[</span><span class="nb">input</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">c</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">finder</span><span class="p">[</span><span class="nb">input</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">DUPLICATE</span>
                <span class="k">if</span> <span class="nb">input</span><span class="o">.</span><span class="n">name</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="n">n_unnamed_inputs</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">named_inputs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">input</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
                <span class="n">inv_finder</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="nb">input</span>
                <span class="n">containers</span><span class="p">[:</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># TODO The following code may need to do something to handle</span>
                <span class="c1"># implicit inputs.</span>

                <span class="c1"># The input is a SymbolicInputKit, so we take as many</span>
                <span class="c1"># containers as the Kit provides inputs</span>
                <span class="n">cs</span> <span class="o">=</span> <span class="n">containers</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">)]</span>
                <span class="c1"># distribute does the initialization of the containers</span>
                <span class="nb">input</span><span class="o">.</span><span class="n">distribute</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">cs</span><span class="p">)</span>
                <span class="n">f</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">distribute</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">cs</span><span class="p">)</span>
                <span class="c1"># Like before, we set a finder entry for the kit. Note that</span>
                <span class="c1"># we are not mapping to a container but to a function which</span>
                <span class="c1"># can reinitialize all the containers</span>
                <span class="n">finder</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">f</span>
                <span class="n">finder</span><span class="p">[</span><span class="nb">input</span><span class="p">]</span> <span class="o">=</span> <span class="n">f</span>
                <span class="k">if</span> <span class="nb">input</span><span class="o">.</span><span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">finder</span><span class="p">:</span>
                    <span class="n">finder</span><span class="p">[</span><span class="nb">input</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">f</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">finder</span><span class="p">[</span><span class="nb">input</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">DUPLICATE</span>
                <span class="c1"># For each input in the kit and its corresponding</span>
                <span class="c1"># container, we put an entry in finder.  This allows</span>
                <span class="c1"># the user to micro-manage elements of the kit if need</span>
                <span class="c1"># be.  All containers inherit the required field and</span>
                <span class="c1"># have their own &quot;provided&quot; counter</span>
                <span class="k">for</span> <span class="n">c</span><span class="p">,</span> <span class="n">sin</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">cs</span><span class="p">,</span> <span class="n">sinputs</span><span class="p">):</span>
                    <span class="n">finder</span><span class="p">[</span><span class="n">sin</span><span class="o">.</span><span class="n">variable</span><span class="p">]</span> <span class="o">=</span> <span class="n">c</span>
                    <span class="n">finder</span><span class="p">[</span><span class="n">sin</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">c</span>
                    <span class="k">if</span> <span class="n">sin</span><span class="o">.</span><span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">finder</span><span class="p">:</span>
                        <span class="n">finder</span><span class="p">[</span><span class="n">sin</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">c</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">finder</span><span class="p">[</span><span class="n">sin</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">DUPLICATE</span>
                    <span class="n">inv_finder</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="nb">input</span>
                    <span class="n">c</span><span class="o">.</span><span class="n">required</span> <span class="o">=</span> <span class="n">required</span>
                    <span class="n">c</span><span class="o">.</span><span class="n">provided</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">containers</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">)]</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">finder</span> <span class="o">=</span> <span class="n">finder</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">inv_finder</span> <span class="o">=</span> <span class="n">inv_finder</span>

        <span class="c1"># this class is important in overriding the square-bracket notation:</span>
        <span class="c1">#     fn.value[x]</span>
        <span class="c1"># self reference is available via the closure on the class</span>
        <span class="k">class</span> <span class="nc">ValueAttribute</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
            <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">s</span> <span class="o">=</span> <span class="n">finder</span><span class="p">[</span><span class="n">item</span><span class="p">]</span>
                <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Unknown input or state: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="n">item</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">s</span> <span class="ow">is</span> <span class="n">DUPLICATE</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Ambiguous name: </span><span class="si">%s</span><span class="s2"> - please check the &quot;</span>
                                    <span class="s2">&quot;names of the inputs of your function &quot;</span>
                                    <span class="s2">&quot;for duplicates.&quot;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="n">item</span><span class="p">))</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">gof</span><span class="o">.</span><span class="n">Container</span><span class="p">):</span>
                    <span class="k">return</span> <span class="n">s</span><span class="o">.</span><span class="n">value</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">NotImplementedError</span>

            <span class="k">def</span> <span class="nf">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">s</span> <span class="o">=</span> <span class="n">finder</span><span class="p">[</span><span class="n">item</span><span class="p">]</span>
                <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                    <span class="c1"># Print informative error message.</span>
                    <span class="n">msg</span> <span class="o">=</span> <span class="n">get_info_on_inputs</span><span class="p">(</span><span class="n">named_inputs</span><span class="p">,</span> <span class="n">n_unnamed_inputs</span><span class="p">)</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Unknown input or state: </span><span class="si">%s</span><span class="s2">. </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span>
                                    <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">item</span><span class="p">),</span> <span class="n">msg</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">s</span> <span class="ow">is</span> <span class="n">DUPLICATE</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Ambiguous name: </span><span class="si">%s</span><span class="s2"> - please check the &quot;</span>
                                    <span class="s2">&quot;names of the inputs of your function &quot;</span>
                                    <span class="s2">&quot;for duplicates.&quot;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="n">item</span><span class="p">))</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">gof</span><span class="o">.</span><span class="n">Container</span><span class="p">):</span>
                    <span class="n">s</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span>
                    <span class="n">s</span><span class="o">.</span><span class="n">provided</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">s</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

            <span class="k">def</span> <span class="nf">__contains__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">finder</span><span class="o">.</span><span class="n">__contains__</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>

        <span class="c1"># this class is important in overriding the square-bracket notation:</span>
        <span class="c1">#     fn.container[x]</span>
        <span class="c1"># self reference is available via the closure on the class</span>
        <span class="k">class</span> <span class="nc">ContainerAttribute</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
            <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">finder</span><span class="p">[</span><span class="n">item</span><span class="p">]</span>

            <span class="k">def</span> <span class="nf">__contains__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">finder</span><span class="o">.</span><span class="n">__contains__</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
            <span class="c1"># You cannot set the container</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_value</span> <span class="o">=</span> <span class="n">ValueAttribute</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_container</span> <span class="o">=</span> <span class="n">ContainerAttribute</span><span class="p">()</span>

        <span class="c1"># Compute self.n_returned_outputs.</span>
        <span class="c1"># This is used only when fn.need_update_inputs is False</span>
        <span class="c1"># because we&#39;re using one of the VM objects and it is</span>
        <span class="c1"># putting updates back into the input containers all by itself.</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">maker</span><span class="o">.</span><span class="n">expanded_inputs</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">input_storage</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_returned_outputs</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output_storage</span><span class="p">)</span>
        <span class="k">for</span> <span class="nb">input</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">maker</span><span class="o">.</span><span class="n">expanded_inputs</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">input</span><span class="o">.</span><span class="n">update</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">n_returned_outputs</span> <span class="o">-=</span> <span class="mi">1</span>

        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">maker</span><span class="o">.</span><span class="n">fgraph</span><span class="o">.</span><span class="n">apply_nodes</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">op</span> <span class="ow">in</span> <span class="n">ops_with_inner_function</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">nodes_with_inner_function</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">op</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__contains__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="o">.</span><span class="n">__contains__</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">[</span><span class="n">item</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">[</span><span class="n">item</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>

    <span class="k">def</span> <span class="nf">__copy__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Copy a function. Copied function have separate intermediate</span>
<span class="sd">        storages and output storages with original function</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">share_memory</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">swap</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">delete_updates</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
             <span class="n">name</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">profile</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Copy this function. Copied function will have separated maker and</span>
<span class="sd">        fgraph with original function. User can choose whether to separate</span>
<span class="sd">        storage by changing the share_memory arguments.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        share_memory : boolean</span>
<span class="sd">            When True, two function share intermediate storages(storages except input and</span>
<span class="sd">            output storages). Otherwise two functions will only share partial</span>
<span class="sd">            storages and same maker. If two functions share memory and</span>
<span class="sd">            allow_gc=False, this will increase executing speed and save memory.</span>

<span class="sd">        swap : dict</span>
<span class="sd">            Dictionary that map old SharedVariables to new</span>
<span class="sd">            SharedVariables. Default is None.</span>
<span class="sd">            NOTE: The shared variable swap in only done in the new returned</span>
<span class="sd">            function, not in the user graph.</span>

<span class="sd">        delete_updates : boolean</span>
<span class="sd">            If True, Copied function will not have updates.</span>
<span class="sd">        name : string</span>
<span class="sd">            If provided, will be the name of the new</span>
<span class="sd">            Function. Otherwise, it will be old + &quot; copy&quot;</span>

<span class="sd">        profile :</span>
<span class="sd">            as theano.function profile parameter</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        theano.Function</span>
<span class="sd">            Copied theano.Function</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># helper function</span>
        <span class="k">def</span> <span class="nf">checkSV</span><span class="p">(</span><span class="n">sv_ori</span><span class="p">,</span> <span class="n">sv_rpl</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Assert two SharedVariable follow some restirctions:</span>
<span class="sd">                1. same type</span>
<span class="sd">                2. same shape or dim?</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">SharedVariable</span> <span class="o">=</span> <span class="n">theano</span><span class="o">.</span><span class="n">tensor</span><span class="o">.</span><span class="n">sharedvar</span><span class="o">.</span><span class="n">SharedVariable</span>
            <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sv_ori</span><span class="p">,</span> <span class="n">SharedVariable</span><span class="p">),</span> <span class="p">(</span>
                <span class="s2">&quot;Key of swap should be SharedVariable, given:&quot;</span><span class="p">,</span> <span class="n">sv_ori</span><span class="p">,</span>
                <span class="s2">&quot; type&quot;</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">sv_ori</span><span class="p">))</span>
            <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sv_rpl</span><span class="p">,</span> <span class="n">SharedVariable</span><span class="p">),</span> <span class="p">(</span>
                <span class="s2">&quot;Value of swap should be SharedVariable, given:&quot;</span><span class="p">,</span> <span class="n">sv_rpl</span><span class="p">,</span>
                <span class="s2">&quot;type&quot;</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">sv_ori</span><span class="p">))</span>
            <span class="k">assert</span> <span class="n">sv_ori</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">sv_rpl</span><span class="o">.</span><span class="n">type</span><span class="p">,</span> <span class="p">(</span>
                <span class="s2">&quot;Type of given SharedVariable conflicts with original one&quot;</span><span class="p">,</span>
                <span class="s2">&quot;Type of given SharedVariable:&quot;</span><span class="p">,</span> <span class="n">sv_rpl</span><span class="o">.</span><span class="n">type</span><span class="p">,</span>
                <span class="s2">&quot;Type of original SharedVariable:&quot;</span><span class="p">,</span> <span class="n">sv_ori</span><span class="o">.</span><span class="n">type</span><span class="p">)</span>

        <span class="n">maker</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">maker</span>

        <span class="c1"># Copy Ins and their storage.</span>
        <span class="c1"># so that they have different storage as their value</span>
        <span class="n">ins</span> <span class="o">=</span> <span class="p">[</span><span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="nb">input</span><span class="p">)</span> <span class="k">for</span> <span class="nb">input</span> <span class="ow">in</span> <span class="n">maker</span><span class="o">.</span><span class="n">inputs</span><span class="p">]</span>

        <span class="c1"># Delete update output in fgraph and updates In instances if needed</span>
        <span class="k">if</span> <span class="n">delete_updates</span><span class="p">:</span>
            <span class="c1"># The first len(maker.outputs) variables are original variables.</span>
            <span class="c1"># The rest are the updates.</span>
            <span class="n">out_vars</span> <span class="o">=</span> <span class="n">maker</span><span class="o">.</span><span class="n">fgraph</span><span class="o">.</span><span class="n">outputs</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="n">maker</span><span class="o">.</span><span class="n">outputs</span><span class="p">)]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">out_vars</span> <span class="o">=</span> <span class="n">maker</span><span class="o">.</span><span class="n">fgraph</span><span class="o">.</span><span class="n">outputs</span>

        <span class="c1"># Init new fgraph using copied variables and get memo</span>
        <span class="c1"># memo: a dict that map old variables to new variables</span>
        <span class="n">memo</span> <span class="o">=</span> <span class="n">graph</span><span class="o">.</span><span class="n">clone_get_equiv</span><span class="p">(</span><span class="n">maker</span><span class="o">.</span><span class="n">fgraph</span><span class="o">.</span><span class="n">inputs</span><span class="p">,</span> <span class="n">out_vars</span><span class="p">)</span>
        <span class="n">fg_cpy</span> <span class="o">=</span> <span class="n">gof</span><span class="o">.</span><span class="n">fg</span><span class="o">.</span><span class="n">FunctionGraph</span><span class="p">([</span><span class="n">memo</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">maker</span><span class="o">.</span><span class="n">fgraph</span><span class="o">.</span><span class="n">inputs</span><span class="p">],</span>
                                      <span class="p">[</span><span class="n">memo</span><span class="p">[</span><span class="n">o</span><span class="p">]</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">out_vars</span><span class="p">],</span>
                                      <span class="n">clone</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>

        <span class="c1"># Re initialize Outs and swap update and variable in Ins</span>
        <span class="c1"># By doing this, we can pass FunctionMaker._check_unused_inputs()</span>
        <span class="n">outs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">SymbolicOutput</span><span class="p">,</span> <span class="n">fg_cpy</span><span class="o">.</span><span class="n">outputs</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="n">maker</span><span class="o">.</span><span class="n">outputs</span><span class="p">)]))</span>
        <span class="k">for</span> <span class="n">out_ori</span><span class="p">,</span> <span class="n">out_cpy</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">maker</span><span class="o">.</span><span class="n">outputs</span><span class="p">,</span> <span class="n">outs</span><span class="p">):</span>
            <span class="n">out_cpy</span><span class="o">.</span><span class="n">borrow</span> <span class="o">=</span> <span class="n">out_ori</span><span class="o">.</span><span class="n">borrow</span>

        <span class="c1"># swap SharedVariable</span>
        <span class="k">if</span> <span class="n">swap</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">exist_svs</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span><span class="o">.</span><span class="n">variable</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">maker</span><span class="o">.</span><span class="n">inputs</span><span class="p">]</span>

            <span class="c1"># Check if given ShareVariables exist</span>
            <span class="k">for</span> <span class="n">sv</span> <span class="ow">in</span> <span class="n">iterkeys</span><span class="p">(</span><span class="n">swap</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">sv</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">exist_svs</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;SharedVariable: </span><span class="si">%s</span><span class="s2"> not found&quot;</span> <span class="o">%</span>
                                     <span class="p">(</span><span class="n">sv</span><span class="o">.</span><span class="n">name</span><span class="p">))</span>

            <span class="c1"># Swap SharedVariable in fgraph and In instances</span>
            <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">in_v</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">ins</span><span class="p">,</span> <span class="n">fg_cpy</span><span class="o">.</span><span class="n">inputs</span><span class="p">)):</span>
                <span class="c1"># Variables in maker.inputs are defined by user, therefore we</span>
                <span class="c1"># use them to make comparision and do the mapping.</span>
                <span class="c1"># Otherwise we don&#39;t touch them.</span>
                <span class="n">var</span> <span class="o">=</span> <span class="n">maker</span><span class="o">.</span><span class="n">inputs</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="o">.</span><span class="n">variable</span>

                <span class="k">if</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">swap</span><span class="p">:</span>
                    <span class="n">swap_sv</span> <span class="o">=</span> <span class="n">swap</span><span class="p">[</span><span class="n">var</span><span class="p">]</span>
                    <span class="n">checkSV</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">variable</span><span class="p">,</span> <span class="n">swap_sv</span><span class="p">)</span>

                    <span class="c1"># swap variable and value of In instances</span>
                    <span class="n">i</span><span class="o">.</span><span class="n">variable</span> <span class="o">=</span> <span class="n">swap_sv</span>
                    <span class="n">i</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">swap_sv</span><span class="o">.</span><span class="n">container</span>

                    <span class="c1"># In the fgraph we use the cloned SharedVariable</span>
                    <span class="n">swap_sv</span> <span class="o">=</span> <span class="n">swap_sv</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span>

                    <span class="c1"># Swap SharedVariable in fgraph</span>
                    <span class="c1"># if inputs was replaced, change self.inputs</span>
                    <span class="n">fg_cpy</span><span class="o">.</span><span class="n">inputs</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">swap_sv</span>
                    <span class="n">fg_cpy</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">in_v</span><span class="p">,</span> <span class="n">swap_sv</span><span class="p">,</span> <span class="n">reason</span><span class="o">=</span><span class="s2">&quot;Swap SV&quot;</span><span class="p">)</span>

        <span class="c1"># Delete update if needed</span>
        <span class="n">update_i</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">outs</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">in_var</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">ins</span><span class="p">,</span> <span class="n">fg_cpy</span><span class="o">.</span><span class="n">inputs</span><span class="p">):</span>
            <span class="n">i</span><span class="o">.</span><span class="n">variable</span> <span class="o">=</span> <span class="n">in_var</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">delete_updates</span> <span class="ow">and</span> <span class="n">i</span><span class="o">.</span><span class="n">update</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">i</span><span class="o">.</span><span class="n">update</span> <span class="o">=</span> <span class="n">fg_cpy</span><span class="o">.</span><span class="n">outputs</span><span class="p">[</span><span class="n">update_i</span><span class="p">]</span>
                <span class="n">update_i</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">i</span><span class="o">.</span><span class="n">update</span> <span class="o">=</span> <span class="bp">None</span>

        <span class="c1"># Construct new storage_map that map new variable to old storage,</span>
        <span class="c1"># so that the ensuing function shares storage with the original one</span>
        <span class="n">storage_map</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fn</span><span class="o">.</span><span class="n">storage_map</span>
        <span class="n">new_storage_map</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="c1"># TODO: We could share the output storage, but we must make sure</span>
        <span class="c1"># 2 different function call won&#39;t override each other values. This</span>
        <span class="c1"># is already done elsewhere, so to reuse it the user would need to</span>
        <span class="c1"># use Out(var, borrow=True) and maybe the mutable=True flag too.</span>
        <span class="c1"># But to be safe for now as it isn&#39;t documented and we aren&#39;t sure</span>
        <span class="c1"># it is well tested, we don&#39;t share the part of the storage_map.</span>
        <span class="k">if</span> <span class="n">share_memory</span><span class="p">:</span>
            <span class="n">i_o_vars</span> <span class="o">=</span> <span class="n">maker</span><span class="o">.</span><span class="n">fgraph</span><span class="o">.</span><span class="n">inputs</span> <span class="o">+</span> <span class="n">maker</span><span class="o">.</span><span class="n">fgraph</span><span class="o">.</span><span class="n">outputs</span>
            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">storage_map</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">i_o_vars</span><span class="p">:</span>
                    <span class="n">new_storage_map</span><span class="p">[</span><span class="n">memo</span><span class="p">[</span><span class="n">key</span><span class="p">]]</span> <span class="o">=</span> <span class="n">storage_map</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">name</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">:</span>
            <span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s2">&quot; copy&quot;</span>

        <span class="n">input_storage</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span><span class="o">.</span><span class="n">value</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">ins</span><span class="p">]</span>
        <span class="c1"># reinitialize new maker and create new function</span>
        <span class="k">if</span> <span class="n">profile</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">profile</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">profile</span>
            <span class="c1"># profile -&gt; True or False</span>
        <span class="k">if</span> <span class="n">profile</span> <span class="ow">is</span> <span class="bp">True</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">name</span><span class="p">:</span>
                <span class="n">message</span> <span class="o">=</span> <span class="n">name</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">message</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">maker</span><span class="o">.</span><span class="n">profile</span><span class="o">.</span><span class="n">message</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot; copy&quot;</span>
            <span class="n">profile</span> <span class="o">=</span> <span class="n">theano</span><span class="o">.</span><span class="n">compile</span><span class="o">.</span><span class="n">profiling</span><span class="o">.</span><span class="n">ProfileStats</span><span class="p">(</span><span class="n">message</span><span class="o">=</span><span class="n">message</span><span class="p">)</span>
            <span class="c1"># profile -&gt; object</span>
        <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">profile</span><span class="p">)</span> <span class="o">==</span> <span class="nb">str</span><span class="p">:</span>
            <span class="n">profile</span> <span class="o">=</span> <span class="n">theano</span><span class="o">.</span><span class="n">compile</span><span class="o">.</span><span class="n">profiling</span><span class="o">.</span><span class="n">ProfileStats</span><span class="p">(</span><span class="n">message</span><span class="o">=</span><span class="n">profile</span><span class="p">)</span>

        <span class="n">f_cpy</span> <span class="o">=</span> <span class="n">maker</span><span class="o">.</span><span class="n">__class__</span><span class="p">(</span><span class="n">inputs</span><span class="o">=</span><span class="n">ins</span><span class="p">,</span> <span class="n">outputs</span><span class="o">=</span><span class="n">outs</span><span class="p">,</span> <span class="n">fgraph</span><span class="o">=</span><span class="n">fg_cpy</span><span class="p">,</span>
                                <span class="n">mode</span><span class="o">=</span><span class="n">maker</span><span class="o">.</span><span class="n">mode</span><span class="p">,</span> <span class="n">profile</span><span class="o">=</span><span class="n">profile</span><span class="p">,</span>
                                <span class="c1"># When removing updates containing variables</span>
                                <span class="c1"># not used in the output function, copy</span>
                                <span class="c1"># generates an unused implicit input.</span>
                                <span class="c1"># We ignore the resulting errors,</span>
                                <span class="c1"># but could change it to &#39;warn&#39; if this might</span>
                                <span class="c1"># cause problems.</span>
                                <span class="n">on_unused_input</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">,</span>
                                <span class="n">function_builder</span><span class="o">=</span><span class="n">maker</span><span class="o">.</span><span class="n">function_builder</span><span class="p">,</span>
                                <span class="c1"># As this is an optimized graph, it</span>
                                <span class="c1"># can contain inplace. DebugMode check</span>
                                <span class="c1"># that.</span>
                                <span class="n">accept_inplace</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
                                <span class="p">)</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">input_storage</span><span class="p">,</span>
                                         <span class="n">storage_map</span><span class="o">=</span><span class="n">new_storage_map</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">in_ori</span><span class="p">,</span> <span class="n">in_cpy</span><span class="p">,</span> <span class="n">ori</span><span class="p">,</span> <span class="n">cpy</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">maker</span><span class="o">.</span><span class="n">inputs</span><span class="p">,</span> <span class="n">f_cpy</span><span class="o">.</span><span class="n">maker</span><span class="o">.</span><span class="n">inputs</span><span class="p">,</span>
                                            <span class="bp">self</span><span class="o">.</span><span class="n">input_storage</span><span class="p">,</span>
                                            <span class="n">f_cpy</span><span class="o">.</span><span class="n">input_storage</span><span class="p">):</span>

            <span class="c1"># Share immutable ShareVariable and constant input&#39;s storage</span>
            <span class="n">swapped</span> <span class="o">=</span> <span class="n">swap</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">and</span> <span class="n">in_ori</span><span class="o">.</span><span class="n">variable</span> <span class="ow">in</span> <span class="n">swap</span>

            <span class="c1"># Using the original storage if SharedVariable will not be updated</span>
            <span class="c1"># and is not swapped</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">in_ori</span><span class="o">.</span><span class="n">mutable</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">swapped</span><span class="p">:</span>
                <span class="n">cpy</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">ori</span><span class="o">.</span><span class="n">data</span>
                <span class="n">in_cpy</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">in_ori</span><span class="o">.</span><span class="n">value</span>

            <span class="c1"># Reconstruct Function.finder which map Variable defined by user</span>
            <span class="c1"># to container, to make Function.value and Function.data work well.</span>
            <span class="c1"># Replace variable in new maker.inputs by the original ones.</span>
            <span class="c1"># So that user can swap SharedVariable in a swapped function</span>
            <span class="n">container</span> <span class="o">=</span> <span class="n">f_cpy</span><span class="o">.</span><span class="n">finder</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">in_cpy</span><span class="o">.</span><span class="n">variable</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">swapped</span><span class="p">:</span>
                <span class="n">f_cpy</span><span class="o">.</span><span class="n">finder</span><span class="p">[</span><span class="n">in_ori</span><span class="o">.</span><span class="n">variable</span><span class="p">]</span> <span class="o">=</span> <span class="n">container</span>
                <span class="n">in_cpy</span><span class="o">.</span><span class="n">vairable</span> <span class="o">=</span> <span class="n">in_ori</span><span class="o">.</span><span class="n">variable</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">f_cpy</span><span class="o">.</span><span class="n">finder</span><span class="p">[</span><span class="n">swap</span><span class="p">[</span><span class="n">in_ori</span><span class="o">.</span><span class="n">variable</span><span class="p">]]</span> <span class="o">=</span> <span class="n">container</span>
                <span class="n">in_cpy</span><span class="o">.</span><span class="n">variable</span> <span class="o">=</span> <span class="n">swap</span><span class="p">[</span><span class="n">in_ori</span><span class="o">.</span><span class="n">variable</span><span class="p">]</span>

        <span class="n">f_cpy</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="n">f_cpy</span><span class="o">.</span><span class="n">maker</span><span class="o">.</span><span class="n">fgraph</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="k">return</span> <span class="n">f_cpy</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Evaluates value of a function on given arguments.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        args : list</span>
<span class="sd">            List of inputs to the function. All inputs are required, even when</span>
<span class="sd">            some of them are not necessary to calculate requested subset of</span>
<span class="sd">            outputs.</span>

<span class="sd">        kwargs : dict</span>
<span class="sd">            The function inputs can be passed as keyword argument. For this, use</span>
<span class="sd">            the name of the input or the input instance as the key.</span>
<span class="sd">            Keyword argument ``output_subset`` is a list of either indices of the</span>
<span class="sd">            function&#39;s outputs or the keys belonging to the `output_keys` dict</span>
<span class="sd">            and represent outputs that are requested to be calculated.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        list</span>
<span class="sd">            List of outputs on indices/keys from ``output_subset`` or all of them,</span>
<span class="sd">            if ``output_subset`` is not passed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">profile</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">profile</span>
        <span class="n">t0</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

        <span class="n">output_subset</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;output_subset&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">output_subset</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_keys</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">output_subset</span> <span class="o">=</span>\
                <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">output_keys</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">output_subset</span><span class="p">]</span>

        <span class="c1"># Reinitialize each container&#39;s &#39;provided&#39; counter</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">trust_input</span><span class="p">:</span>
            <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">args</span><span class="p">:</span>
                <span class="n">s</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_storage</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">s</span><span class="o">.</span><span class="n">storage</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">arg</span>
                <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_storage</span><span class="p">:</span>
                <span class="n">c</span><span class="o">.</span><span class="n">provided</span> <span class="o">=</span> <span class="mi">0</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">input_storage</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Too many parameter passed to theano function&quot;</span><span class="p">)</span>

            <span class="c1"># Set positional arguments</span>
            <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">args</span><span class="p">:</span>
                <span class="c1"># TODO: provide a Param option for skipping the filter if we</span>
                <span class="c1">#      really want speed.</span>
                <span class="n">s</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_storage</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="c1"># see this emails for a discuation about None as input</span>
                <span class="c1"># https://groups.google.com/group/theano-dev/browse_thread/thread/920a5e904e8a8525/4f1b311a28fc27e5</span>
                <span class="k">if</span> <span class="n">arg</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="n">s</span><span class="o">.</span><span class="n">storage</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">arg</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">s</span><span class="o">.</span><span class="n">storage</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span>
                            <span class="n">arg</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="n">s</span><span class="o">.</span><span class="n">strict</span><span class="p">,</span>
                            <span class="n">allow_downcast</span><span class="o">=</span><span class="n">s</span><span class="o">.</span><span class="n">allow_downcast</span><span class="p">)</span>

                    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                        <span class="n">function_name</span> <span class="o">=</span> <span class="s2">&quot;theano function&quot;</span>
                        <span class="n">argument_name</span> <span class="o">=</span> <span class="s2">&quot;argument&quot;</span>
                        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">:</span>
                            <span class="n">function_name</span> <span class="o">+=</span> <span class="s1">&#39; with name &quot;&#39;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s1">&#39;&quot;&#39;</span>
                        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="s1">&#39;name&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">arg</span><span class="o">.</span><span class="n">name</span><span class="p">:</span>
                            <span class="n">argument_name</span> <span class="o">+=</span> <span class="s1">&#39; with name &quot;&#39;</span> <span class="o">+</span> <span class="n">arg</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s1">&#39;&quot;&#39;</span>
                        <span class="n">e</span><span class="o">.</span><span class="n">args</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;Bad input &quot;</span> <span class="o">+</span> <span class="n">argument_name</span> <span class="o">+</span> <span class="s2">&quot; to &quot;</span> <span class="o">+</span>
                                  <span class="n">function_name</span> <span class="o">+</span> <span class="s2">&quot; at index </span><span class="si">%d</span><span class="s2"> (0-based)&quot;</span>
                                  <span class="o">%</span> <span class="n">i</span><span class="p">,)</span> <span class="o">+</span> <span class="n">e</span><span class="o">.</span><span class="n">args</span>
                        <span class="k">raise</span>
                <span class="n">s</span><span class="o">.</span><span class="n">provided</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="c1"># Set keyword arguments</span>
        <span class="k">if</span> <span class="n">kwargs</span><span class="p">:</span>  <span class="c1"># for speed, skip the iteritems for empty kwargs</span>
            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">iteritems</span><span class="p">(</span><span class="n">kwargs</span><span class="p">):</span>
                <span class="bp">self</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">arg</span>

        <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">trust_input</span> <span class="ow">and</span>
                <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;_check_for_aliased_inputs&#39;</span><span class="p">,</span> <span class="bp">True</span><span class="p">)):</span>
            <span class="c1"># Collect aliased inputs among the storage space</span>
            <span class="n">args_share_memory</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">input_storage</span><span class="p">)):</span>
                <span class="n">i_var</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">maker</span><span class="o">.</span><span class="n">inputs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">variable</span>
                <span class="n">i_val</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_storage</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">storage</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">i_var</span><span class="o">.</span><span class="n">type</span><span class="p">,</span> <span class="s1">&#39;may_share_memory&#39;</span><span class="p">):</span>
                    <span class="n">is_aliased</span> <span class="o">=</span> <span class="bp">False</span>
                    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">args_share_memory</span><span class="p">)):</span>

                        <span class="n">group_j</span> <span class="o">=</span> <span class="n">izip</span><span class="p">(</span>
                            <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">maker</span><span class="o">.</span><span class="n">inputs</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">variable</span> <span class="k">for</span> <span class="n">k</span>
                             <span class="ow">in</span> <span class="n">args_share_memory</span><span class="p">[</span><span class="n">j</span><span class="p">]],</span>
                            <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">input_storage</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">storage</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span>
                             <span class="ow">in</span> <span class="n">args_share_memory</span><span class="p">[</span><span class="n">j</span><span class="p">]])</span>
                        <span class="k">if</span> <span class="n">numpy</span><span class="o">.</span><span class="n">any</span><span class="p">([(</span><span class="n">var</span><span class="o">.</span><span class="n">type</span> <span class="ow">is</span> <span class="n">i_var</span><span class="o">.</span><span class="n">type</span> <span class="ow">and</span>
                                       <span class="n">var</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">may_share_memory</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">i_val</span><span class="p">))</span>
                                      <span class="k">for</span> <span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span> <span class="ow">in</span> <span class="n">group_j</span><span class="p">]):</span>

                            <span class="n">is_aliased</span> <span class="o">=</span> <span class="bp">True</span>
                            <span class="n">args_share_memory</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                            <span class="k">break</span>

                    <span class="k">if</span> <span class="ow">not</span> <span class="n">is_aliased</span><span class="p">:</span>
                        <span class="n">args_share_memory</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">i</span><span class="p">])</span>

                <span class="c1"># Check for groups of more than one argument that share memory</span>
                <span class="k">for</span> <span class="n">group</span> <span class="ow">in</span> <span class="n">args_share_memory</span><span class="p">:</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">group</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="c1"># copy all but the first</span>
                        <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">group</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">input_storage</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">storage</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">input_storage</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">storage</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

        <span class="c1"># Check if inputs are missing, or if inputs were set more than once, or</span>
        <span class="c1"># if we tried to provide inputs that are supposed to be implicit.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">trust_input</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_storage</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">required</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">c</span><span class="o">.</span><span class="n">provided</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Missing required input: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span>
                                    <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">inv_finder</span><span class="p">[</span><span class="n">c</span><span class="p">],</span> <span class="s1">&#39;variable&#39;</span><span class="p">,</span>
                                            <span class="bp">self</span><span class="o">.</span><span class="n">inv_finder</span><span class="p">[</span><span class="n">c</span><span class="p">]))</span>
                <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">provided</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Multiple values for input: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span>
                                    <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">inv_finder</span><span class="p">[</span><span class="n">c</span><span class="p">],</span> <span class="s1">&#39;variable&#39;</span><span class="p">,</span>
                                            <span class="bp">self</span><span class="o">.</span><span class="n">inv_finder</span><span class="p">[</span><span class="n">c</span><span class="p">]))</span>
                <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">implicit</span> <span class="ow">and</span> <span class="n">c</span><span class="o">.</span><span class="n">provided</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                        <span class="s1">&#39;Tried to provide value for implicit input: </span><span class="si">%s</span><span class="s1">&#39;</span>
                        <span class="o">%</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">inv_finder</span><span class="p">[</span><span class="n">c</span><span class="p">],</span> <span class="s1">&#39;variable&#39;</span><span class="p">,</span>
                                  <span class="bp">self</span><span class="o">.</span><span class="n">inv_finder</span><span class="p">[</span><span class="n">c</span><span class="p">]))</span>

        <span class="c1"># Do the actual work</span>
        <span class="n">t0_fn</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">outputs</span> <span class="o">=</span>\
                <span class="bp">self</span><span class="o">.</span><span class="n">fn</span><span class="p">()</span> <span class="k">if</span> <span class="n">output_subset</span> <span class="ow">is</span> <span class="bp">None</span> <span class="k">else</span>\
                <span class="bp">self</span><span class="o">.</span><span class="n">fn</span><span class="p">(</span><span class="n">output_subset</span><span class="o">=</span><span class="n">output_subset</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fn</span><span class="p">,</span> <span class="s1">&#39;position_of_error&#39;</span><span class="p">):</span>
                <span class="c1"># this is a new vm-provided function or c linker</span>
                <span class="c1"># they need this because the exception manipulation</span>
                <span class="c1"># done by raise_with_op is not implemented in C.</span>
                <span class="n">thunk</span> <span class="o">=</span> <span class="bp">None</span>
                <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fn</span><span class="p">,</span> <span class="s1">&#39;thunks&#39;</span><span class="p">):</span>
                    <span class="n">thunk</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fn</span><span class="o">.</span><span class="n">thunks</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">fn</span><span class="o">.</span><span class="n">position_of_error</span><span class="p">]</span>
                <span class="n">gof</span><span class="o">.</span><span class="n">link</span><span class="o">.</span><span class="n">raise_with_op</span><span class="p">(</span>
                    <span class="n">node</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">fn</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">fn</span><span class="o">.</span><span class="n">position_of_error</span><span class="p">],</span>
                    <span class="n">thunk</span><span class="o">=</span><span class="n">thunk</span><span class="p">,</span>
                    <span class="n">storage_map</span><span class="o">=</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fn</span><span class="p">,</span> <span class="s1">&#39;storage_map&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># old-style linkers raise their own exceptions</span>
                <span class="k">raise</span>

        <span class="n">dt_fn</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">t0_fn</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">maker</span><span class="o">.</span><span class="n">mode</span><span class="o">.</span><span class="n">fn_time</span> <span class="o">+=</span> <span class="n">dt_fn</span>
        <span class="k">if</span> <span class="n">profile</span><span class="p">:</span>
            <span class="n">profile</span><span class="o">.</span><span class="n">vm_call_time</span> <span class="o">+=</span> <span class="n">dt_fn</span>

        <span class="c1"># Retrieve the values that were computed</span>
        <span class="k">if</span> <span class="n">outputs</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">outputs</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">data</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_storage</span><span class="p">]</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">outputs</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output_storage</span><span class="p">)</span>

        <span class="c1"># Remove internal references to required inputs.</span>
        <span class="c1"># These cannot be re-used anyway.</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_storage</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">required</span><span class="p">:</span>
                <span class="n">c</span><span class="o">.</span><span class="n">storage</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="bp">None</span>

        <span class="c1"># if we are allowing garbage collection, remove the</span>
        <span class="c1"># output reference from the internal storage cells</span>
        <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fn</span><span class="p">,</span> <span class="s1">&#39;allow_gc&#39;</span><span class="p">,</span> <span class="bp">False</span><span class="p">):</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output_storage</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">maker</span><span class="o">.</span><span class="n">fgraph</span><span class="o">.</span><span class="n">outputs</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">o_container</span><span class="p">,</span> <span class="n">o_variable</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output_storage</span><span class="p">,</span>
                                               <span class="bp">self</span><span class="o">.</span><span class="n">maker</span><span class="o">.</span><span class="n">fgraph</span><span class="o">.</span><span class="n">outputs</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">o_variable</span><span class="o">.</span><span class="n">owner</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="c1"># this node is the variable of computation</span>
                    <span class="c1"># WARNING: This circumvents the &#39;readonly&#39; attribute in x</span>
                    <span class="n">o_container</span><span class="o">.</span><span class="n">storage</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="bp">None</span>

        <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fn</span><span class="p">,</span> <span class="s1">&#39;need_update_inputs&#39;</span><span class="p">,</span> <span class="bp">True</span><span class="p">):</span>
            <span class="c1"># Update the inputs that have an update function</span>
            <span class="k">for</span> <span class="nb">input</span><span class="p">,</span> <span class="n">storage</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">maker</span><span class="o">.</span><span class="n">expanded_inputs</span><span class="p">,</span>
                                                    <span class="bp">self</span><span class="o">.</span><span class="n">input_storage</span><span class="p">))):</span>
                <span class="k">if</span> <span class="nb">input</span><span class="o">.</span><span class="n">update</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="n">storage</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">outputs</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">outputs</span> <span class="o">=</span> <span class="n">outputs</span><span class="p">[:</span><span class="bp">self</span><span class="o">.</span><span class="n">n_returned_outputs</span><span class="p">]</span>

        <span class="c1"># Put default values back in the storage</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">required</span><span class="p">,</span> <span class="n">refeed</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">defaults</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">refeed</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">gof</span><span class="o">.</span><span class="n">Container</span><span class="p">):</span>
                    <span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">storage</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
        <span class="c1">#</span>
        <span class="c1"># NOTE: This logic needs to be replicated in</span>
        <span class="c1">#       scan.</span>
        <span class="c1">#       grep for &#39;PROFILE_CODE&#39;</span>
        <span class="c1">#</span>

        <span class="n">dt_call</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">t0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">maker</span><span class="o">.</span><span class="n">mode</span><span class="o">.</span><span class="n">call_time</span> <span class="o">+=</span> <span class="n">dt_call</span>
        <span class="k">if</span> <span class="n">profile</span><span class="p">:</span>
            <span class="n">profile</span><span class="o">.</span><span class="n">fct_callcount</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">profile</span><span class="o">.</span><span class="n">fct_call_time</span> <span class="o">+=</span> <span class="n">dt_call</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fn</span><span class="p">,</span> <span class="s1">&#39;update_profile&#39;</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">fn</span><span class="o">.</span><span class="n">update_profile</span><span class="p">(</span><span class="n">profile</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">profile</span><span class="o">.</span><span class="n">ignore_first_call</span><span class="p">:</span>
                <span class="n">profile</span><span class="o">.</span><span class="n">reset</span><span class="p">()</span>
                <span class="n">profile</span><span class="o">.</span><span class="n">ignore_first_call</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">return_none</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">None</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">unpack_single</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">outputs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span>\
                <span class="n">output_subset</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">outputs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_keys</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>

                <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output_keys</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">outputs</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">output_subset</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span><span class="n">izip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output_keys</span><span class="p">,</span> <span class="n">outputs</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="nb">dict</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">output_keys</span><span class="p">[</span><span class="n">index</span><span class="p">],</span> <span class="n">outputs</span><span class="p">[</span><span class="n">index</span><span class="p">])</span>
                                <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">output_subset</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">output_subset</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">outputs</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">[</span><span class="n">outputs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">output_subset</span><span class="p">]</span>

    <span class="n">value</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span>
        <span class="k">lambda</span> <span class="bp">self</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_value</span><span class="p">,</span>
        <span class="bp">None</span><span class="p">,</span>  <span class="c1"># this property itself is not settable</span>
        <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;dictionary-like access to the values associated with Variables&quot;</span><span class="p">)</span>
    <span class="n">container</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span>
        <span class="k">lambda</span> <span class="bp">self</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_container</span><span class="p">,</span>
        <span class="bp">None</span><span class="p">,</span>  <span class="c1"># this property itself is not settable</span>
        <span class="n">doc</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;dictionary-like access to the containers associated with &quot;</span>
             <span class="s2">&quot;Variables&quot;</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">free</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        When allow_gc = False, clear the Variables in storage_map</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># 1.no allow_gc return False</span>
        <span class="c1"># 2.has allow_gc, if allow_gc is False, return True</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fn</span><span class="p">,</span> <span class="s1">&#39;allow_gc&#39;</span><span class="p">,</span> <span class="bp">True</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">fn</span><span class="o">.</span><span class="n">storage_map</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">theano</span><span class="o">.</span><span class="n">gof</span><span class="o">.</span><span class="n">Constant</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">fn</span><span class="o">.</span><span class="n">storage_map</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="bp">None</span>

            <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes_with_inner_function</span><span class="p">:</span>
                <span class="n">ops_with_inner_function</span><span class="p">[</span><span class="n">node</span><span class="o">.</span><span class="n">op</span><span class="p">]</span><span class="o">.</span><span class="n">free</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">get_shared</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the shared variable read or updated by by this function.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">i</span><span class="o">.</span><span class="n">variable</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">maker</span><span class="o">.</span><span class="n">inputs</span> <span class="k">if</span> <span class="n">i</span><span class="o">.</span><span class="n">implicit</span><span class="p">]</span>


<span class="c1"># pickling/deepcopy support for Function</span>
<span class="k">def</span> <span class="nf">_pickle_Function</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
    <span class="c1"># copy of the input storage list</span>
    <span class="n">ins</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">input_storage</span><span class="p">)</span>
    <span class="n">input_storage</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">inputs</span><span class="p">),</span> <span class="p">(</span><span class="n">required</span><span class="p">,</span> <span class="n">refeed</span><span class="p">,</span> <span class="n">default</span><span class="p">)</span> <span class="ow">in</span> \
            <span class="nb">zip</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">indices</span><span class="p">,</span> <span class="n">f</span><span class="o">.</span><span class="n">defaults</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="n">SymbolicInputKit</span><span class="p">):</span>
            <span class="n">li</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">default</span><span class="p">:</span>
                <span class="n">input_storage</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ins</span><span class="p">[:</span><span class="n">li</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">input_storage</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">default</span><span class="p">)</span>
            <span class="n">ins</span><span class="p">[:</span><span class="n">li</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">input_storage</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ins</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">del</span> <span class="n">ins</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="n">inputs_data</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">data</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">f</span><span class="o">.</span><span class="n">input_storage</span><span class="p">]</span>

    <span class="c1"># HACK to detect aliased storage.</span>
    <span class="c1"># This is here because aliased relationships are not [currently]</span>
    <span class="c1"># preserved across the pickle operation</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">pickle_aliased_memory_strategy</span> <span class="o">==</span> <span class="s1">&#39;ignore&#39;</span><span class="p">):</span>
        <span class="n">all_data</span> <span class="o">=</span> <span class="n">input_storage</span> <span class="o">+</span> <span class="n">inputs_data</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">d_i</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">all_data</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">d_j</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">all_data</span><span class="p">):</span>
                <span class="k">if</span> <span class="p">((</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">j</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">d_i</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="ow">and</span>
                        <span class="nb">isinstance</span><span class="p">(</span><span class="n">d_j</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)):</span>
                    <span class="k">if</span> <span class="n">numpy</span><span class="o">.</span><span class="n">may_share_memory</span><span class="p">(</span><span class="n">d_i</span><span class="p">,</span> <span class="n">d_j</span><span class="p">):</span>
                        <span class="k">if</span> <span class="n">f</span><span class="o">.</span><span class="n">pickle_aliased_memory_strategy</span> <span class="o">==</span> <span class="s1">&#39;warn&#39;</span><span class="p">:</span>
                            <span class="n">_logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;aliased relationship between &#39;</span>
                                            <span class="s1">&#39;Function arguments </span><span class="si">%s</span><span class="s1">, </span><span class="si">%s</span><span class="s1"> &#39;</span>
                                            <span class="s1">&#39;will not be preserved by &#39;</span>
                                            <span class="s1">&#39;un-pickling operation&#39;</span> <span class="o">%</span>
                                            <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">d_i</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="n">d_j</span><span class="p">)))</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="k">raise</span> <span class="n">AliasedMemoryError</span><span class="p">(</span><span class="n">d_i</span><span class="p">,</span> <span class="n">d_j</span><span class="p">)</span>
    <span class="n">rval</span> <span class="o">=</span> <span class="p">(</span><span class="n">_constructor_Function</span><span class="p">,</span> <span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">maker</span><span class="p">,</span> <span class="n">input_storage</span><span class="p">,</span> <span class="n">inputs_data</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">rval</span>


<span class="k">def</span> <span class="nf">_constructor_Function</span><span class="p">(</span><span class="n">maker</span><span class="p">,</span> <span class="n">input_storage</span><span class="p">,</span> <span class="n">inputs_data</span><span class="p">):</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">theano</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">unpickle_function</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">None</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">maker</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">input_storage</span><span class="p">,</span> <span class="n">trustme</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">input_storage</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">inputs_data</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">container</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">input_storage</span><span class="p">,</span> <span class="n">inputs_data</span><span class="p">):</span>
        <span class="k">assert</span> <span class="p">(</span><span class="n">container</span><span class="o">.</span><span class="n">data</span> <span class="ow">is</span> <span class="n">x</span><span class="p">)</span> <span class="ow">or</span> \
            <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">container</span><span class="o">.</span><span class="n">data</span> <span class="o">==</span> <span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">())</span> <span class="ow">or</span> \
            <span class="p">(</span><span class="n">container</span><span class="o">.</span><span class="n">data</span> <span class="o">==</span> <span class="n">x</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">f</span>

<span class="n">copyreg</span><span class="o">.</span><span class="n">pickle</span><span class="p">(</span><span class="n">Function</span><span class="p">,</span> <span class="n">_pickle_Function</span><span class="p">)</span>


<span class="c1">###</span>
<span class="c1"># FunctionMaker</span>
<span class="c1">###</span>

<span class="k">def</span> <span class="nf">insert_deepcopy</span><span class="p">(</span><span class="n">fgraph</span><span class="p">,</span> <span class="n">wrapped_inputs</span><span class="p">,</span> <span class="n">wrapped_outputs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Insert deepcopy in the fgraph to break aliasing of outputs</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># This loop was inserted to remove aliasing between outputs when</span>
    <span class="c1"># they all evaluate to the same value. Originally it was OK for</span>
    <span class="c1"># outputs to be aliased, but some of the outputs can be shared</span>
    <span class="c1"># variables, and is not good for shared variables to be</span>
    <span class="c1"># aliased. It might be possible to optimize this by making sure</span>
    <span class="c1"># there is no aliasing only between shared variables.</span>

    <span class="c1"># If some outputs are constant, we add deep copy to respect the</span>
    <span class="c1"># memory contract</span>

    <span class="c1"># We don&#39;t insert deep copy when the output.borrow is True for all</span>
    <span class="c1"># conserned outputs.</span>

    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">wrapped_inputs</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">fgraph</span><span class="o">.</span><span class="n">inputs</span><span class="p">)</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">wrapped_outputs</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">fgraph</span><span class="o">.</span><span class="n">outputs</span><span class="p">)</span>
    <span class="n">reason</span> <span class="o">=</span> <span class="s2">&quot;insert_deepcopy&quot;</span>
    <span class="n">updated_fgraph_inputs</span> <span class="o">=</span> <span class="p">[</span><span class="n">fgraph_i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">fgraph_i</span> <span class="ow">in</span>
                             <span class="nb">zip</span><span class="p">(</span><span class="n">wrapped_inputs</span><span class="p">,</span> <span class="n">fgraph</span><span class="o">.</span><span class="n">inputs</span><span class="p">)</span>
                             <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="s1">&#39;update&#39;</span><span class="p">,</span> <span class="bp">False</span><span class="p">)]</span>

    <span class="c1"># We can&#39;t use fgraph.inputs as this don&#39;t include Constant Value.</span>
    <span class="n">all_graph_inputs</span> <span class="o">=</span> <span class="n">gof</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">inputs</span><span class="p">(</span><span class="n">fgraph</span><span class="o">.</span><span class="n">outputs</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">fgraph</span><span class="o">.</span><span class="n">outputs</span><span class="p">)):</span>
        <span class="n">views_of_output_i</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="n">view_tree_set</span><span class="p">(</span><span class="n">alias_root</span><span class="p">(</span><span class="n">fgraph</span><span class="o">.</span><span class="n">outputs</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span> <span class="n">views_of_output_i</span><span class="p">)</span>
        <span class="n">copied</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="c1"># do not allow outputs to be aliased</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">fgraph</span><span class="o">.</span><span class="n">outputs</span><span class="p">)):</span>
            <span class="c1"># We could don&#39;t put deep copy if both outputs have borrow==True</span>
            <span class="c1"># and not(wrapped_outputs[i].borrow and wrapped_outputs[j].borrow):</span>
            <span class="k">if</span> <span class="n">fgraph</span><span class="o">.</span><span class="n">outputs</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="ow">in</span> <span class="n">views_of_output_i</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">wrapped_outputs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">borrow</span> <span class="ow">and</span> <span class="n">wrapped_outputs</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">borrow</span><span class="p">:</span>
                    <span class="n">fgraph</span><span class="o">.</span><span class="n">change_input</span><span class="p">(</span><span class="s1">&#39;output&#39;</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span>
                                        <span class="n">view_op</span><span class="p">(</span><span class="n">fgraph</span><span class="o">.</span><span class="n">outputs</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span>
                                        <span class="n">reason</span><span class="o">=</span><span class="n">reason</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">fgraph</span><span class="o">.</span><span class="n">change_input</span><span class="p">(</span><span class="s1">&#39;output&#39;</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span>
                                        <span class="n">deep_copy_op</span><span class="p">(</span><span class="n">fgraph</span><span class="o">.</span><span class="n">outputs</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span>
                                        <span class="n">reason</span><span class="o">=</span><span class="n">reason</span><span class="p">)</span>
                <span class="n">copied</span> <span class="o">=</span> <span class="bp">True</span>
                <span class="k">break</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">copied</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">input_j</span> <span class="ow">in</span> <span class="n">all_graph_inputs</span><span class="p">:</span>
                <span class="c1"># do not allow outputs to be aliased to an inputs (j), unless</span>
                <span class="c1"># a) that j&#39;th input has been &#39;destroyed&#39; by</span>
                <span class="c1">#    e.g. in-place computations</span>
                <span class="c1"># b) that j&#39;th input is a shared variable that is also</span>
                <span class="c1">#    being updated</span>
                <span class="k">if</span> <span class="p">(</span><span class="nb">hasattr</span><span class="p">(</span><span class="n">fgraph</span><span class="p">,</span> <span class="s1">&#39;get_destroyers_of&#39;</span><span class="p">)</span> <span class="ow">and</span>
                        <span class="n">fgraph</span><span class="o">.</span><span class="n">get_destroyers_of</span><span class="p">(</span><span class="n">input_j</span><span class="p">)):</span>
                    <span class="k">continue</span>
                <span class="k">if</span> <span class="n">input_j</span> <span class="ow">in</span> <span class="n">updated_fgraph_inputs</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="k">if</span> <span class="n">input_j</span> <span class="ow">in</span> <span class="n">views_of_output_i</span><span class="p">:</span>
                    <span class="c1"># We don&#39;t put deep_copy_op if the input and the</span>
                    <span class="c1"># output have borrow==True</span>
                    <span class="k">if</span> <span class="n">input_j</span> <span class="ow">in</span> <span class="n">fgraph</span><span class="o">.</span><span class="n">inputs</span><span class="p">:</span>
                        <span class="n">j</span> <span class="o">=</span> <span class="n">fgraph</span><span class="o">.</span><span class="n">inputs</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">input_j</span><span class="p">)</span>
                        <span class="k">if</span> <span class="p">(</span><span class="n">wrapped_outputs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">borrow</span> <span class="ow">and</span>
                                <span class="n">wrapped_inputs</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">borrow</span><span class="p">):</span>
                            <span class="n">fgraph</span><span class="o">.</span><span class="n">change_input</span><span class="p">(</span><span class="s1">&#39;output&#39;</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span>
                                                <span class="n">view_op</span><span class="p">(</span><span class="n">fgraph</span><span class="o">.</span><span class="n">outputs</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span>
                                                <span class="n">reason</span><span class="o">=</span><span class="s2">&quot;insert_deepcopy&quot;</span><span class="p">)</span>
                            <span class="k">break</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">fgraph</span><span class="o">.</span><span class="n">change_input</span><span class="p">(</span>
                                <span class="s1">&#39;output&#39;</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span>
                                <span class="n">deep_copy_op</span><span class="p">(</span><span class="n">fgraph</span><span class="o">.</span><span class="n">outputs</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span>
                                <span class="n">reason</span><span class="o">=</span><span class="s2">&quot;insert_deepcopy&quot;</span><span class="p">)</span>
                            <span class="k">break</span>
                    <span class="k">elif</span> <span class="n">wrapped_outputs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">borrow</span><span class="p">:</span>
                        <span class="n">fgraph</span><span class="o">.</span><span class="n">change_input</span><span class="p">(</span><span class="s1">&#39;output&#39;</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span>
                                            <span class="n">view_op</span><span class="p">(</span><span class="n">fgraph</span><span class="o">.</span><span class="n">outputs</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span>
                                            <span class="n">reason</span><span class="o">=</span><span class="s2">&quot;insert_deepcopy&quot;</span><span class="p">)</span>
                        <span class="k">break</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">fgraph</span><span class="o">.</span><span class="n">change_input</span><span class="p">(</span><span class="s1">&#39;output&#39;</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span>
                                            <span class="n">deep_copy_op</span><span class="p">(</span><span class="n">fgraph</span><span class="o">.</span><span class="n">outputs</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span>
                                            <span class="n">reason</span><span class="o">=</span><span class="s2">&quot;insert_deepcopy&quot;</span><span class="p">)</span>
                        <span class="k">break</span>

<span class="n">NODEFAULT</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;NODEFAULT&#39;</span><span class="p">]</span>


<span class="k">class</span> <span class="nc">FunctionMaker</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    `FunctionMaker` is the class to `create` `Function` instances.</span>

<span class="sd">    This class has the fgraph, the optimizer, and the linker. When</span>
<span class="sd">    copying a `Function`, there is no need to duplicate the</span>
<span class="sd">    `FunctionMaker` instance. Deepcopy still copies both, which can</span>
<span class="sd">    variable in re-compilation.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    inputs : list of SymbolicInput instances</span>
<span class="sd">    outputs : list of SymbolicOutput instances</span>
<span class="sd">        Outputs may also be a single Variable (not a list), in which case the</span>
<span class="sd">        functions produced by FunctionMaker will return their output value</span>
<span class="sd">        directly.</span>
<span class="sd">    mode : Mode instance</span>
<span class="sd">        Telling FunctionMaker how to optimize and link. None means to use the</span>
<span class="sd">        `config.mode`.</span>
<span class="sd">    accept_inplace : bool</span>
<span class="sd">        True iff it is acceptable to have inplace operations in the graph from</span>
<span class="sd">        the inputs to the outputs.</span>
<span class="sd">    on_unused_input : {&#39;raise&#39;, &#39;warn&#39;, &#39;ignore&#39;, None}</span>
<span class="sd">        What to do if a variable in the &#39;inputs&#39; list is not used in the graph.</span>
<span class="sd">        Possible values are:</span>
<span class="sd">        - &#39;raise&#39;: raise an error</span>
<span class="sd">        - &#39;warn&#39;: log a warning</span>
<span class="sd">        - &#39;ignore&#39;: do not do anything</span>
<span class="sd">        - None: Use the value in the Theano flags on_unused_input.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">wrap_in</span><span class="p">(</span><span class="nb">input</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="p">(</span><span class="n">SymbolicInput</span><span class="p">,</span> <span class="n">SymbolicInputKit</span><span class="p">)):</span>
            <span class="k">return</span> <span class="nb">input</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="n">gof</span><span class="o">.</span><span class="n">Variable</span><span class="p">):</span>
            <span class="c1"># r -&gt; SymbolicInput(variable=r)</span>
            <span class="k">return</span> <span class="n">SymbolicInput</span><span class="p">(</span><span class="nb">input</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
            <span class="c1"># (r, u) -&gt; SymbolicInput(variable=r, update=u)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nb">input</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">SymbolicInput</span><span class="p">(</span><span class="nb">input</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">update</span><span class="o">=</span><span class="nb">input</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Expected two elements in the list or tuple.&quot;</span><span class="p">,</span>
                                <span class="nb">input</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Unknown input type: </span><span class="si">%s</span><span class="s2"> (</span><span class="si">%s</span><span class="s2">), expected Variable &quot;</span>
                            <span class="s2">&quot;instance&quot;</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="nb">input</span><span class="p">),</span> <span class="nb">input</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">expand_in</span><span class="p">(</span><span class="n">sinput</span><span class="p">,</span> <span class="n">rinputs</span><span class="p">):</span>
        <span class="c1"># For SymbolicInputKits, this extracts a list of SymbolicInput</span>
        <span class="c1"># instances and corresponding indices such that these</span>
        <span class="c1"># SymbolicInputs are representative of some of the Variable</span>
        <span class="c1"># instances in inputs.  For SymbolicInput, this returns None</span>
        <span class="c1"># as the list of indices and a list with just the</span>
        <span class="c1"># SymbolicInput.</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sinput</span><span class="p">,</span> <span class="n">SymbolicInputKit</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">sinput</span><span class="o">.</span><span class="n">complete</span><span class="p">(</span><span class="n">rinputs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sinput</span><span class="p">,</span> <span class="n">SymbolicInput</span><span class="p">):</span>
            <span class="k">return</span> <span class="p">[</span><span class="bp">None</span><span class="p">,</span> <span class="p">[</span><span class="n">sinput</span><span class="p">]]</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">wrap_out</span><span class="p">(</span><span class="n">output</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="n">SymbolicOutput</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">output</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="n">gof</span><span class="o">.</span><span class="n">Variable</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">SymbolicOutput</span><span class="p">(</span><span class="n">output</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Unknown output type: </span><span class="si">%s</span><span class="s2"> (</span><span class="si">%s</span><span class="s2">)&quot;</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">output</span><span class="p">),</span>
                            <span class="n">output</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">optimize_graph_with_cache</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">optimizer</span><span class="p">,</span> <span class="n">inputs</span><span class="p">,</span> <span class="n">outputs</span><span class="p">):</span>
        <span class="c1"># This function is not finished</span>
        <span class="kn">from</span> <span class="nn">theano.gof.compilelock</span> <span class="kn">import</span> <span class="n">get_lock</span><span class="p">,</span> <span class="n">release_lock</span>
        <span class="kn">import</span> <span class="nn">os.path</span>

        <span class="n">graph_db_file</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">theano</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">compiledir</span><span class="p">,</span>
                                     <span class="s1">&#39;optimized_graphs.pkl&#39;</span><span class="p">)</span>

        <span class="c1"># the inputs, outputs, and size of the graph to be optimized</span>
        <span class="n">inputs_new</span> <span class="o">=</span> <span class="p">[</span><span class="n">inp</span><span class="o">.</span><span class="n">variable</span> <span class="k">for</span> <span class="n">inp</span> <span class="ow">in</span> <span class="n">inputs</span><span class="p">]</span>
        <span class="n">outputs_new</span> <span class="o">=</span> <span class="p">[</span><span class="n">out</span><span class="o">.</span><span class="n">variable</span> <span class="k">for</span> <span class="n">out</span> <span class="ow">in</span> <span class="n">outputs</span><span class="p">]</span>
        <span class="n">size_new</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fgraph</span><span class="o">.</span><span class="n">apply_nodes</span><span class="p">)</span>
        <span class="n">get_lock</span><span class="p">()</span>
        <span class="c1"># Beginning of cache optimizations.</span>
        <span class="c1"># Could be refactored in different functions.</span>

        <span class="k">def</span> <span class="nf">load_graph_db</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">graph_db_file</span><span class="p">):</span>
                <span class="k">print</span><span class="p">(</span><span class="s1">&#39;graph_db already exists&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># create graph_db</span>
                <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">graph_db_file</span><span class="p">,</span> <span class="s1">&#39;wb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
                    <span class="k">print</span><span class="p">(</span><span class="s1">&#39;create new graph_db in </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">graph_db_file</span><span class="p">)</span>
            <span class="c1"># load the graph_db dictionary</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">graph_db_file</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
                    <span class="c1"># Temporary hack to allow</span>
                    <span class="c1"># theano.scan_module.tests.test_scan.T_Scan to</span>
                    <span class="c1"># finish. Should be changed in definitive version.</span>
                    <span class="n">tmp</span> <span class="o">=</span> <span class="n">theano</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">unpickle_function</span>
                    <span class="n">theano</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">unpickle_function</span> <span class="o">=</span> <span class="bp">False</span>
                    <span class="n">graph_db</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
                <span class="k">print</span><span class="p">(</span><span class="s1">&#39;graph_db loaded and it is not empty&#39;</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">EOFError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="c1"># the file has nothing in it</span>
                <span class="k">print</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
                <span class="k">print</span><span class="p">(</span><span class="s1">&#39;graph_db loaded and it is empty&#39;</span><span class="p">)</span>
                <span class="n">graph_db</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">finally</span><span class="p">:</span>
                <span class="n">theano</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">unpickle_function</span> <span class="o">=</span> <span class="n">tmp</span>

            <span class="k">return</span> <span class="n">graph_db</span>

        <span class="k">def</span> <span class="nf">find_same_graph_in_db</span><span class="p">(</span><span class="n">graph_db</span><span class="p">):</span>
            <span class="c1"># If found_graph_in_db is None, then need to optimize.</span>
            <span class="c1"># Otherwise, return the graph found.</span>
            <span class="n">found_graph_in_db</span> <span class="o">=</span> <span class="bp">None</span>
            <span class="c1"># The sole purpose of this loop is to set &#39;need_optimize&#39; by</span>
            <span class="c1"># going through graph_db, looking for graph that has the same</span>
            <span class="c1"># computation performed.</span>
            <span class="k">for</span> <span class="n">graph_old</span><span class="p">,</span> <span class="n">graph_optimized</span> <span class="ow">in</span> <span class="n">iteritems</span><span class="p">(</span><span class="n">graph_db</span><span class="p">):</span>
                <span class="n">inputs_old</span> <span class="o">=</span> <span class="n">graph_old</span><span class="o">.</span><span class="n">inputs</span>
                <span class="n">outputs_old</span> <span class="o">=</span> <span class="n">graph_old</span><span class="o">.</span><span class="n">outputs</span>
                <span class="n">size_old</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">graph_old</span><span class="o">.</span><span class="n">apply_nodes</span><span class="p">)</span>
                <span class="c1"># Some heuristics to check is the same graphs have</span>
                <span class="c1"># already been optimized before.</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">inputs_new</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">inputs_old</span><span class="p">):</span>
                    <span class="c1"># If the inputs are of different size,</span>
                    <span class="c1"># two graphs are for sure different</span>
                    <span class="k">print</span><span class="p">(</span><span class="s1">&#39;need to optimize, because input size is different&#39;</span><span class="p">)</span>
                    <span class="k">continue</span>
                <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">outputs_new</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">outputs_old</span><span class="p">):</span>
                    <span class="c1"># If the inputs are of different size,</span>
                    <span class="c1"># two graphs are for sure different</span>
                    <span class="k">print</span><span class="p">(</span><span class="s1">&#39;need to optimize, because output size is different&#39;</span><span class="p">)</span>
                    <span class="k">continue</span>
                <span class="k">elif</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="n">input_new</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">input_old</span><span class="o">.</span><span class="n">type</span>
                             <span class="k">for</span> <span class="n">input_new</span><span class="p">,</span> <span class="n">input_old</span> <span class="ow">in</span>
                             <span class="nb">zip</span><span class="p">(</span><span class="n">inputs_new</span><span class="p">,</span> <span class="n">inputs_old</span><span class="p">)):</span>
                    <span class="k">print</span><span class="p">(</span><span class="s1">&#39;need to optimize, because inputs are of different &#39;</span>
                          <span class="s1">&#39;types&#39;</span><span class="p">)</span>
                    <span class="k">continue</span>
                <span class="k">elif</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="n">output_new</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">output_old</span><span class="o">.</span><span class="n">type</span>
                             <span class="k">for</span> <span class="n">output_new</span><span class="p">,</span> <span class="n">output_old</span> <span class="ow">in</span>
                             <span class="nb">zip</span><span class="p">(</span><span class="n">outputs_new</span><span class="p">,</span> <span class="n">outputs_old</span><span class="p">)):</span>
                    <span class="k">print</span><span class="p">(</span><span class="s1">&#39;need to optimize, because outputs are of different &#39;</span>
                          <span class="s1">&#39;types&#39;</span><span class="p">)</span>
                    <span class="k">continue</span>
                <span class="k">elif</span> <span class="ow">not</span> <span class="n">size_old</span> <span class="o">==</span> <span class="n">size_new</span><span class="p">:</span>
                    <span class="k">print</span><span class="p">(</span><span class="s1">&#39;need to optimize, because numbers of nodes in graph&#39;</span>
                          <span class="s1">&#39; are different&#39;</span><span class="p">)</span>
                    <span class="k">continue</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">flags</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">output_new</span><span class="p">,</span> <span class="n">output_old</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span>
                            <span class="nb">zip</span><span class="p">(</span><span class="n">outputs_new</span><span class="p">,</span> <span class="n">outputs_old</span><span class="p">)):</span>
                        <span class="k">print</span><span class="p">(</span><span class="s1">&#39;loop through outputs node for both graphs&#39;</span><span class="p">)</span>
                        <span class="n">graph_old</span><span class="o">.</span><span class="n">variables</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">gof</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">variables</span><span class="p">(</span>
                            <span class="n">graph_old</span><span class="o">.</span><span class="n">inputs</span><span class="p">,</span> <span class="n">graph_old</span><span class="o">.</span><span class="n">outputs</span><span class="p">))</span>

                        <span class="c1"># using clone allowed to avoid a lot of errors</span>
                        <span class="c1"># deep copy seemed to had.</span>
                        <span class="n">f2</span> <span class="o">=</span> <span class="n">graph_old</span><span class="o">.</span><span class="n">clone</span><span class="p">(</span><span class="n">check_integrity</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
                        <span class="n">t1</span> <span class="o">=</span> <span class="n">output_new</span>
                        <span class="n">t2</span> <span class="o">=</span> <span class="n">f2</span><span class="o">.</span><span class="n">outputs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

                        <span class="c1"># Used to remove &quot;already used by another graph error</span>
                        <span class="k">def</span> <span class="nf">removeAllFgraph</span><span class="p">(</span><span class="n">remove</span><span class="p">):</span>
                            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">remove</span><span class="p">,</span> <span class="s1">&#39;fgraph&#39;</span><span class="p">):</span>
                                <span class="k">del</span> <span class="n">remove</span><span class="o">.</span><span class="n">fgraph</span>
                            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">remove</span><span class="p">,</span> <span class="s1">&#39;owner&#39;</span><span class="p">):</span>
                                <span class="k">if</span> <span class="n">remove</span><span class="o">.</span><span class="n">owner</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                                    <span class="k">pass</span>
                                <span class="k">else</span><span class="p">:</span>
                                    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">remove</span><span class="o">.</span><span class="n">owner</span><span class="p">,</span> <span class="s1">&#39;fgraph&#39;</span><span class="p">):</span>
                                        <span class="k">del</span> <span class="n">remove</span><span class="o">.</span><span class="n">owner</span><span class="o">.</span><span class="n">fgraph</span>
                                    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">remove</span><span class="o">.</span><span class="n">owner</span><span class="p">,</span> <span class="s1">&#39;inputs&#39;</span><span class="p">):</span>
                                        <span class="n">remove</span><span class="o">.</span><span class="n">owner</span><span class="o">.</span><span class="n">inputs</span> <span class="o">=</span> <span class="p">[</span><span class="n">removeAllFgraph</span><span class="p">(</span>
                                            <span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">remove</span><span class="o">.</span><span class="n">owner</span><span class="o">.</span><span class="n">inputs</span><span class="p">]</span>
                                        <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">remove</span><span class="o">.</span><span class="n">owner</span><span class="o">.</span><span class="n">outputs</span><span class="p">:</span>
                                            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="s1">&#39;fgraph&#39;</span><span class="p">):</span>
                                                <span class="k">del</span> <span class="n">o</span><span class="o">.</span><span class="n">fgraph</span>
                            <span class="k">return</span> <span class="n">remove</span>

                        <span class="n">t2</span> <span class="o">=</span> <span class="n">removeAllFgraph</span><span class="p">(</span><span class="n">t2</span><span class="p">)</span>

                        <span class="n">givens</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">izip</span><span class="p">(</span><span class="n">gof</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">inputs</span><span class="p">([</span><span class="n">t1</span><span class="p">]),</span>
                                           <span class="n">gof</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">inputs</span><span class="p">([</span><span class="n">t2</span><span class="p">])))</span>

                        <span class="n">temp</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">izip</span><span class="p">(</span><span class="n">gof</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">inputs</span><span class="p">([</span><span class="n">t1</span><span class="p">]),</span>
                                         <span class="n">gof</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">inputs</span><span class="p">([</span><span class="n">t2</span><span class="p">])))</span>

                        <span class="c1"># hack to remove inconstent entry in givens</span>
                        <span class="c1"># seems to work that but source of inconsistency</span>
                        <span class="c1"># could be worth investigating.</span>
                        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">iteritems</span><span class="p">(</span><span class="n">temp</span><span class="p">):</span>
                            <span class="k">if</span> <span class="n">key</span><span class="o">.</span><span class="n">type</span> <span class="o">!=</span> <span class="n">value</span><span class="o">.</span><span class="n">type</span><span class="p">:</span>
                                <span class="k">del</span> <span class="n">givens</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

                        <span class="n">flag</span> <span class="o">=</span> <span class="n">is_same_graph</span><span class="p">(</span><span class="n">t1</span><span class="p">,</span> <span class="n">t2</span><span class="p">,</span> <span class="n">givens</span><span class="o">=</span><span class="n">givens</span><span class="p">)</span>

                        <span class="n">flags</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">flag</span><span class="p">)</span>

                    <span class="n">is_same</span> <span class="o">=</span> <span class="nb">all</span><span class="p">(</span><span class="n">flags</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">is_same</span><span class="p">:</span>
                        <span class="c1"># found the match</span>
                        <span class="k">print</span><span class="p">(</span><span class="s1">&#39;found a match, no need to optimize&#39;</span><span class="p">)</span>
                        <span class="n">found_graph_in_db</span> <span class="o">=</span> <span class="n">graph_optimized</span>
                        <span class="k">break</span>
            <span class="k">return</span> <span class="n">found_graph_in_db</span>

        <span class="n">graph_db</span> <span class="o">=</span> <span class="n">load_graph_db</span><span class="p">()</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">&#39;loaded graph_db from </span><span class="si">%s</span><span class="s1">, size=</span><span class="si">%d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">graph_db_file</span><span class="p">,</span>
                                                    <span class="nb">len</span><span class="p">(</span><span class="n">graph_db</span><span class="p">)))</span>
        <span class="n">found_graph</span> <span class="o">=</span> <span class="n">find_same_graph_in_db</span><span class="p">(</span><span class="n">graph_db</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">found_graph</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fgraph</span> <span class="o">=</span> <span class="n">found_graph</span>
            <span class="n">optimizer_profile</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># this is a brand new graph, optimize it, save it to graph_db</span>
            <span class="k">print</span><span class="p">(</span><span class="s1">&#39;graph not found in graph_db, optimizing the graph&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fgraph</span><span class="o">.</span><span class="n">variables</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">gof</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">variables</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">fgraph</span><span class="o">.</span><span class="n">inputs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">fgraph</span><span class="o">.</span><span class="n">outputs</span><span class="p">))</span>
            <span class="c1"># check_integrity parameters was added to ignore</span>
            <span class="c1"># &quot;excess cached variables&quot; errors. Works that way</span>
            <span class="c1"># but once again the error couldbe worth</span>
            <span class="c1"># investigating.</span>
            <span class="n">before_opt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fgraph</span><span class="o">.</span><span class="n">clone</span><span class="p">(</span><span class="n">check_integrity</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
            <span class="n">optimizer_profile</span> <span class="o">=</span> <span class="n">optimizer</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fgraph</span><span class="p">)</span>
            <span class="n">graph_db</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">before_opt</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">fgraph</span><span class="p">})</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">graph_db_file</span><span class="p">,</span> <span class="s1">&#39;wb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
                <span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">graph_db</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">print</span><span class="p">(</span><span class="s1">&#39;new graph saved into graph_db&#39;</span><span class="p">)</span>
        <span class="n">release_lock</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">optimizer_profile</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inputs</span><span class="p">,</span> <span class="n">outputs</span><span class="p">,</span>
                 <span class="n">mode</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">accept_inplace</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">function_builder</span><span class="o">=</span><span class="n">Function</span><span class="p">,</span>
                 <span class="n">profile</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">on_unused_input</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">fgraph</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                 <span class="n">output_keys</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="n">mode</span> <span class="o">=</span> <span class="n">theano</span><span class="o">.</span><span class="n">compile</span><span class="o">.</span><span class="n">mode</span><span class="o">.</span><span class="n">get_mode</span><span class="p">(</span><span class="n">mode</span><span class="p">)</span>

        <span class="c1"># figure out which profile object to use (if any)</span>
        <span class="c1"># to help with forward-porting ProfileMode,</span>
        <span class="c1"># we allow ProfileMode to provide a ProfileStats object</span>
        <span class="c1"># using this somewhat awkward mechanism.</span>
        <span class="n">mode_profile</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">mode</span><span class="p">,</span> <span class="s1">&#39;profile&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">profile</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">and</span>
                <span class="n">profile</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">False</span> <span class="ow">and</span>
                <span class="n">mode_profile</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s1">&#39;profile passed via both &quot;mode&quot; and &quot;profile&quot; arguments&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">profile</span> <span class="o">=</span> <span class="n">profile</span> <span class="o">=</span> <span class="n">profile</span> <span class="ow">or</span> <span class="n">mode_profile</span>
        <span class="k">if</span> <span class="n">profile</span><span class="p">:</span>
            <span class="c1"># This is very important:</span>
            <span class="c1"># 1) We preload the cache here to don&#39;t have its timming</span>
            <span class="c1">#    included in optimization that compile function.</span>
            <span class="c1"># 2) Do not refresh the cache here by default. It cause</span>
            <span class="c1">#    too much execution time during testing as we compile</span>
            <span class="c1">#    much more functions then the number of compile c</span>
            <span class="c1">#    module.</span>
            <span class="n">theano</span><span class="o">.</span><span class="n">gof</span><span class="o">.</span><span class="n">cc</span><span class="o">.</span><span class="n">get_module_cache</span><span class="p">()</span><span class="o">.</span><span class="n">refresh</span><span class="p">()</span>
        <span class="c1"># Handle the case where inputs and/or outputs is a single</span>
        <span class="c1"># Variable (not in a list)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">orig_outputs</span> <span class="o">=</span> <span class="n">outputs</span>
        <span class="n">unpack_single</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="n">return_none</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="k">if</span> <span class="n">outputs</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">return_none</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="n">outputs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">outputs</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
            <span class="n">unpack_single</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="n">outputs</span> <span class="o">=</span> <span class="p">[</span><span class="n">outputs</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">inputs</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
            <span class="n">inputs</span> <span class="o">=</span> <span class="p">[</span><span class="n">inputs</span><span class="p">]</span>

        <span class="c1"># Wrap them in In or Out instances if needed.</span>
        <span class="n">inputs</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">wrap_in</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">inputs</span><span class="p">]</span>
        <span class="n">outputs</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">wrap_out</span><span class="p">(</span><span class="n">o</span><span class="p">)</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">outputs</span><span class="p">]</span>
        <span class="n">_inputs</span> <span class="o">=</span> <span class="n">gof</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">inputs</span><span class="p">([</span><span class="n">o</span><span class="o">.</span><span class="n">variable</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">outputs</span><span class="p">]</span> <span class="o">+</span>
                                   <span class="p">[</span><span class="n">i</span><span class="o">.</span><span class="n">update</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">inputs</span>
                                    <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="s1">&#39;update&#39;</span><span class="p">,</span> <span class="bp">False</span><span class="p">)])</span>

        <span class="c1"># Check if some input variables are unused</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_unused_inputs</span><span class="p">(</span><span class="n">inputs</span><span class="p">,</span> <span class="n">outputs</span><span class="p">,</span> <span class="n">on_unused_input</span><span class="p">)</span>

        <span class="c1"># Make a list of (SymbolicInput|SymblicInputKits, indices,</span>
        <span class="c1"># [SymbolicInput,...]), one tuple for each input. (See</span>
        <span class="c1"># Function.indices for more details)</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="p">[[</span><span class="nb">input</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">expand_in</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="n">_inputs</span><span class="p">)</span>
                   <span class="k">for</span> <span class="nb">input</span> <span class="ow">in</span> <span class="n">inputs</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">fgraph</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">need_opt</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="c1"># make the fgraph (copies the graph, creates NEW INPUT AND</span>
            <span class="c1"># OUTPUT VARIABLES)</span>
            <span class="n">fgraph</span><span class="p">,</span> <span class="n">additional_outputs</span> <span class="o">=</span> <span class="n">std_fgraph</span><span class="p">(</span><span class="n">inputs</span><span class="p">,</span> <span class="n">outputs</span><span class="p">,</span>
                                                    <span class="n">accept_inplace</span><span class="p">)</span>
            <span class="n">fgraph</span><span class="o">.</span><span class="n">profile</span> <span class="o">=</span> <span class="n">profile</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># fgraph is already an optimized one</span>
            <span class="n">need_opt</span> <span class="o">=</span> <span class="bp">False</span>
            <span class="n">updates</span> <span class="o">=</span> <span class="p">[</span><span class="n">spec</span><span class="o">.</span><span class="n">update</span> <span class="k">for</span> <span class="n">spec</span> <span class="ow">in</span> <span class="n">inputs</span> <span class="k">if</span> <span class="n">spec</span><span class="o">.</span><span class="n">update</span><span class="p">]</span>
            <span class="n">additional_outputs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">SymbolicOutput</span><span class="p">,</span> <span class="n">updates</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">fgraph</span> <span class="o">=</span> <span class="n">fgraph</span>

        <span class="c1"># Fetch the optimizer and linker</span>
        <span class="n">optimizer</span><span class="p">,</span> <span class="n">linker</span> <span class="o">=</span> <span class="n">mode</span><span class="o">.</span><span class="n">optimizer</span><span class="p">,</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">mode</span><span class="o">.</span><span class="n">linker</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">need_opt</span><span class="p">:</span>
            <span class="n">compute_test_value_orig</span> <span class="o">=</span> <span class="n">theano</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">compute_test_value</span>
            <span class="n">limit_orig</span> <span class="o">=</span> <span class="n">theano</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">traceback</span><span class="o">.</span><span class="n">limit</span>
            <span class="c1"># Why we add stack on node when it get done in output var?</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="c1"># optimize the fgraph</span>
                <span class="n">theano</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">compute_test_value</span> <span class="o">=</span> \
                    <span class="n">theano</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">compute_test_value_opt</span>
                <span class="n">theano</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">traceback</span><span class="o">.</span><span class="n">limit</span> <span class="o">=</span> <span class="n">theano</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">traceback</span><span class="o">.</span><span class="n">compile_limit</span>
                <span class="n">start_optimizer</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

                <span class="c1"># now optimize the graph</span>
                <span class="k">if</span> <span class="n">theano</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">cache_optimizations</span><span class="p">:</span>
                    <span class="n">optimizer_profile</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">optimize_graph_with_cache</span><span class="p">(</span>
                        <span class="n">optimizer</span><span class="p">,</span> <span class="n">inputs</span><span class="p">,</span> <span class="n">outputs</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">optimizer_profile</span> <span class="o">=</span> <span class="n">optimizer</span><span class="p">(</span><span class="n">fgraph</span><span class="p">)</span>

                <span class="n">end_optimizer</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
                <span class="n">opt_time</span> <span class="o">=</span> <span class="n">end_optimizer</span> <span class="o">-</span> <span class="n">start_optimizer</span>
                <span class="k">if</span> <span class="n">profile</span><span class="p">:</span>
                    <span class="n">profile</span><span class="o">.</span><span class="n">optimizer_time</span> <span class="o">+=</span> <span class="n">opt_time</span>
                    <span class="k">if</span> <span class="n">theano</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">profile_optimizer</span><span class="p">:</span>
                        <span class="n">profile</span><span class="o">.</span><span class="n">optimizer_profile</span> <span class="o">=</span> <span class="p">(</span><span class="n">optimizer</span><span class="p">,</span>
                                                     <span class="n">optimizer_profile</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">theano</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">profile_optimizer</span><span class="p">:</span>
                    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">((</span>
                        <span class="s2">&quot;config.profile_optimizer requires config.profile to &quot;</span>
                        <span class="s2">&quot; be set to True as well&quot;</span><span class="p">),</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
                <span class="n">_logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Optimizing took </span><span class="si">%f</span><span class="s1"> seconds&#39;</span><span class="p">,</span> <span class="n">opt_time</span><span class="p">)</span>

                <span class="c1"># Add deep copy to respect the memory interface</span>
                <span class="n">insert_deepcopy</span><span class="p">(</span><span class="n">fgraph</span><span class="p">,</span> <span class="n">inputs</span><span class="p">,</span> <span class="n">outputs</span> <span class="o">+</span> <span class="n">additional_outputs</span><span class="p">)</span>
            <span class="k">finally</span><span class="p">:</span>
                <span class="n">theano</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">compute_test_value</span> <span class="o">=</span> <span class="n">compute_test_value_orig</span>
                <span class="n">theano</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">traceback</span><span class="o">.</span><span class="n">limit</span> <span class="o">=</span> <span class="n">limit_orig</span>

        <span class="c1"># initialize the linker</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">linker</span><span class="p">,</span> <span class="s1">&#39;accept&#39;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;&#39;linker&#39; parameter of FunctionMaker should be &quot;</span>
                             <span class="s2">&quot;a Linker with an accept method or one of </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span>
                             <span class="nb">list</span><span class="p">(</span><span class="n">theano</span><span class="o">.</span><span class="n">compile</span><span class="o">.</span><span class="n">mode</span>
                                  <span class="o">.</span><span class="n">predefined_linkers</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>

        <span class="c1"># the &#39;no_borrow&#39; outputs are the ones for which that we can&#39;t</span>
        <span class="c1"># return the internal storage pointer.</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">fgraph</span><span class="o">.</span><span class="n">outputs</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">outputs</span> <span class="o">+</span> <span class="n">additional_outputs</span><span class="p">)</span>
        <span class="n">no_borrow</span> <span class="o">=</span> <span class="p">[</span><span class="n">output</span> <span class="k">for</span> <span class="n">output</span><span class="p">,</span> <span class="n">spec</span> <span class="ow">in</span>
                     <span class="nb">zip</span><span class="p">(</span><span class="n">fgraph</span><span class="o">.</span><span class="n">outputs</span><span class="p">,</span> <span class="n">outputs</span> <span class="o">+</span> <span class="n">additional_outputs</span><span class="p">)</span>
                     <span class="k">if</span> <span class="ow">not</span> <span class="n">spec</span><span class="o">.</span><span class="n">borrow</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">no_borrow</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">linker</span> <span class="o">=</span> <span class="n">linker</span><span class="o">.</span><span class="n">accept</span><span class="p">(</span>
                <span class="n">fgraph</span><span class="p">,</span> <span class="n">no_recycling</span><span class="o">=</span><span class="n">infer_reuse_pattern</span><span class="p">(</span><span class="n">fgraph</span><span class="p">,</span> <span class="n">no_borrow</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">linker</span> <span class="o">=</span> <span class="n">linker</span><span class="o">.</span><span class="n">accept</span><span class="p">(</span><span class="n">fgraph</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">linker</span><span class="p">,</span> <span class="s1">&#39;accept_var_updates&#39;</span><span class="p">):</span>
            <span class="c1"># hacky thing so VMLinker knows about updates</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">linker</span><span class="o">.</span><span class="n">accept_var_updates</span><span class="p">(</span>
                <span class="n">fgraph_updated_vars</span><span class="p">(</span><span class="n">fgraph</span><span class="p">,</span> <span class="n">inputs</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">indices</span> <span class="o">=</span> <span class="n">indices</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span> <span class="o">=</span> <span class="n">inputs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">expanded_inputs</span> <span class="o">=</span> <span class="n">inputs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">outputs</span> <span class="o">=</span> <span class="n">outputs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">unpack_single</span> <span class="o">=</span> <span class="n">unpack_single</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">return_none</span> <span class="o">=</span> <span class="n">return_none</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mode</span> <span class="o">=</span> <span class="n">mode</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">accept_inplace</span> <span class="o">=</span> <span class="n">accept_inplace</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">function_builder</span> <span class="o">=</span> <span class="n">function_builder</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">on_unused_input</span> <span class="o">=</span> <span class="n">on_unused_input</span>  <span class="c1"># Used for the pickling/copy</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">output_keys</span> <span class="o">=</span> <span class="n">output_keys</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">required</span> <span class="o">=</span> <span class="p">[(</span><span class="n">i</span><span class="o">.</span><span class="n">value</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">refeed</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">and</span>
             <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">gof</span><span class="o">.</span><span class="n">Container</span><span class="p">)</span> <span class="ow">and</span>
             <span class="n">i</span><span class="o">.</span><span class="n">update</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">_check_unused_inputs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inputs</span><span class="p">,</span> <span class="n">outputs</span><span class="p">,</span> <span class="n">on_unused_input</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">on_unused_input</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">on_unused_input</span> <span class="o">=</span> <span class="n">theano</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">on_unused_input</span>

        <span class="k">if</span> <span class="n">on_unused_input</span> <span class="o">==</span> <span class="s1">&#39;ignore&#39;</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="c1"># There should be two categories of variables in inputs:</span>
        <span class="c1">#  - variables that have to be provided (used_inputs)</span>
        <span class="c1">#  - shared variables that will be updated</span>
        <span class="n">used_inputs</span> <span class="o">=</span> <span class="n">gof</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">ancestors</span><span class="p">(</span>
            <span class="p">([</span><span class="n">o</span><span class="o">.</span><span class="n">variable</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">outputs</span><span class="p">]</span> <span class="o">+</span>
             <span class="p">[</span><span class="n">i</span><span class="o">.</span><span class="n">update</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">inputs</span> <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="s1">&#39;update&#39;</span><span class="p">,</span> <span class="bp">False</span><span class="p">)]),</span>
            <span class="n">blockers</span><span class="o">=</span><span class="p">[</span><span class="n">i</span><span class="o">.</span><span class="n">variable</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">inputs</span><span class="p">])</span>

        <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;theano.function was asked to create a function computing &quot;</span>
               <span class="s2">&quot;outputs given certain inputs, but the provided input &quot;</span>
               <span class="s2">&quot;variable at index </span><span class="si">%i</span><span class="s2"> is not part of the computational graph &quot;</span>
               <span class="s2">&quot;needed to compute the outputs: </span><span class="si">%s</span><span class="s2">.</span><span class="se">\n</span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">warn_msg</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;To make this warning into an error, you can pass the &quot;</span>
                    <span class="s2">&quot;parameter on_unused_input=&#39;raise&#39; to theano.function. &quot;</span>
                    <span class="s2">&quot;To disable it completely, use on_unused_input=&#39;ignore&#39;.&quot;</span><span class="p">)</span>
        <span class="n">err_msg</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;To make this error into a warning, you can pass the &quot;</span>
                   <span class="s2">&quot;parameter on_unused_input=&#39;warn&#39; to theano.function. &quot;</span>
                   <span class="s2">&quot;To disable it completely, use on_unused_input=&#39;ignore&#39;.&quot;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">inputs</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">((</span><span class="n">i</span><span class="o">.</span><span class="n">variable</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">used_inputs</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">update</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">)):</span>
                <span class="k">if</span> <span class="n">on_unused_input</span> <span class="o">==</span> <span class="s1">&#39;warn&#39;</span><span class="p">:</span>
                    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">msg</span> <span class="o">%</span> <span class="p">(</span><span class="n">inputs</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="n">i</span><span class="o">.</span><span class="n">variable</span><span class="p">,</span>
                                         <span class="n">warn_msg</span><span class="p">),</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">6</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">on_unused_input</span> <span class="o">==</span> <span class="s1">&#39;raise&#39;</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">UnusedInputError</span><span class="p">(</span><span class="n">msg</span> <span class="o">%</span> <span class="p">(</span><span class="n">inputs</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">i</span><span class="p">),</span>
                                                  <span class="n">i</span><span class="o">.</span><span class="n">variable</span><span class="p">,</span> <span class="n">err_msg</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Invalid value for keyword &quot;</span>
                                     <span class="s2">&quot;on_unused_input of theano.function: &quot;</span>
                                     <span class="s2">&quot;&#39;</span><span class="si">%s</span><span class="s2">&#39;.</span><span class="se">\n</span><span class="s2">Valid values are &#39;raise&#39;, &quot;</span>
                                     <span class="s2">&quot;&#39;warn&#39;, and &#39;ignore&#39;.&quot;</span> <span class="o">%</span> <span class="n">on_unused_input</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">create</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">input_storage</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">trustme</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">storage_map</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a function.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        input_storage</span>
<span class="sd">            A list matching the inputs list and providing default values if the</span>
<span class="sd">            default for an input is None, then that input is a required input.</span>
<span class="sd">            For an input with an update, the default acts as initialization.</span>
<span class="sd">        trustme</span>
<span class="sd">            Disables some exceptions, used internally.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">input_storage</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">input_storage</span> <span class="o">=</span> <span class="p">[</span><span class="bp">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="p">)</span>
        <span class="c1"># list of independent one-element lists, will be passed to the linker</span>
        <span class="n">input_storage_lists</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">defaults</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># The following loop is to fill in the input_storage_lists and</span>
        <span class="c1"># defaults lists.</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">indices</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">input_storage</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">((</span><span class="nb">input</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">subinputs</span><span class="p">),</span> <span class="n">input_storage_i</span><span class="p">)</span> <span class="ow">in</span> \
                <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">indices</span><span class="p">,</span> <span class="n">input_storage</span><span class="p">)):</span>

            <span class="c1"># Replace any default value given as a variable by its</span>
            <span class="c1"># container.  Note that this makes sense only in the</span>
            <span class="c1"># context of shared variables, but for now we avoid</span>
            <span class="c1"># dealing directly with them to avoid dependency on the</span>
            <span class="c1"># shared variables work-in-progress repository.</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">input_storage_i</span><span class="p">,</span> <span class="n">gof</span><span class="o">.</span><span class="n">Variable</span><span class="p">):</span>
                <span class="n">input_storage_i</span> <span class="o">=</span> <span class="n">input_storage_i</span><span class="o">.</span><span class="n">container</span>

            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">input_storage_i</span><span class="p">,</span> <span class="n">gof</span><span class="o">.</span><span class="n">Container</span><span class="p">):</span>
                <span class="c1"># If the default is a gof.Container, this means we want to</span>
                <span class="c1"># share the same storage. This is done by appending</span>
                <span class="c1"># input_storage_i.storage to input_storage_lists.</span>
                <span class="k">if</span> <span class="n">indices</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Cannot take a Container instance as &quot;</span>
                                    <span class="s2">&quot;default for a SymbolicInputKit.&quot;</span><span class="p">)</span>
                <span class="n">input_storage_lists</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">input_storage_i</span><span class="o">.</span><span class="n">storage</span><span class="p">)</span>

                <span class="n">storage</span> <span class="o">=</span> <span class="n">input_storage</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">storage</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Normal case: one new, independent storage unit</span>
                <span class="n">input_storage_lists</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">input_storage_i</span><span class="p">])</span>

                <span class="n">storage</span> <span class="o">=</span> <span class="n">input_storage_i</span>

            <span class="n">required</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">required</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">refeed</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">refeed</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="c1"># sanity check-- if an input is required it should not</span>
            <span class="c1"># need to be refed</span>
            <span class="k">assert</span> <span class="ow">not</span> <span class="p">(</span><span class="n">required</span> <span class="ow">and</span> <span class="n">refeed</span><span class="p">)</span>

            <span class="c1"># shared variables need neither be input by the user nor refed</span>
            <span class="k">if</span> <span class="nb">input</span><span class="o">.</span><span class="n">shared</span><span class="p">:</span>
                <span class="k">assert</span> <span class="ow">not</span> <span class="n">required</span>
                <span class="k">assert</span> <span class="ow">not</span> <span class="n">refeed</span>
                <span class="n">storage</span> <span class="o">=</span> <span class="bp">None</span>

            <span class="c1"># if an input is required, it never need be refed</span>
            <span class="k">if</span> <span class="n">required</span><span class="p">:</span>
                <span class="n">storage</span> <span class="o">=</span> <span class="bp">None</span>

            <span class="c1"># make sure that we only store a value if we actually need it</span>
            <span class="k">if</span> <span class="n">storage</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">assert</span> <span class="n">refeed</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">required</span>

            <span class="n">defaults</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">required</span><span class="p">,</span> <span class="n">refeed</span><span class="p">,</span> <span class="n">storage</span><span class="p">))</span>

        <span class="c1"># Get a function instance</span>
        <span class="n">start_linker</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="n">start_import_time</span> <span class="o">=</span> <span class="n">theano</span><span class="o">.</span><span class="n">gof</span><span class="o">.</span><span class="n">cmodule</span><span class="o">.</span><span class="n">import_time</span>
        <span class="n">limit_orig</span> <span class="o">=</span> <span class="n">theano</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">traceback</span><span class="o">.</span><span class="n">limit</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">theano</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">traceback</span><span class="o">.</span><span class="n">limit</span> <span class="o">=</span> <span class="n">theano</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">traceback</span><span class="o">.</span><span class="n">compile_limit</span>
            <span class="n">_fn</span><span class="p">,</span> <span class="n">_i</span><span class="p">,</span> <span class="n">_o</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">linker</span><span class="o">.</span><span class="n">make_thunk</span><span class="p">(</span>
                <span class="n">input_storage</span><span class="o">=</span><span class="n">input_storage_lists</span><span class="p">,</span> <span class="n">storage_map</span><span class="o">=</span><span class="n">storage_map</span><span class="p">)</span>
        <span class="k">finally</span><span class="p">:</span>
            <span class="n">theano</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">traceback</span><span class="o">.</span><span class="n">limit</span> <span class="o">=</span> <span class="n">limit_orig</span>

        <span class="n">end_linker</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

        <span class="n">linker_time</span> <span class="o">=</span> <span class="n">end_linker</span> <span class="o">-</span> <span class="n">start_linker</span>
        <span class="n">_logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Linker took </span><span class="si">%f</span><span class="s1"> seconds&#39;</span><span class="p">,</span> <span class="n">linker_time</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">profile</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">profile</span><span class="o">.</span><span class="n">linker_time</span> <span class="o">+=</span> <span class="n">linker_time</span>
            <span class="n">_fn</span><span class="o">.</span><span class="n">time_thunks</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">profile</span><span class="o">.</span><span class="n">flag_time_thunks</span>
            <span class="n">import_time</span> <span class="o">=</span> <span class="n">theano</span><span class="o">.</span><span class="n">gof</span><span class="o">.</span><span class="n">cmodule</span><span class="o">.</span><span class="n">import_time</span> <span class="o">-</span> <span class="n">start_import_time</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">profile</span><span class="o">.</span><span class="n">import_time</span> <span class="o">+=</span> <span class="n">import_time</span>

        <span class="n">fn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">function_builder</span><span class="p">(</span><span class="n">_fn</span><span class="p">,</span> <span class="n">_i</span><span class="p">,</span> <span class="n">_o</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">indices</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">outputs</span><span class="p">,</span>
                                   <span class="n">defaults</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">unpack_single</span><span class="p">,</span>
                                   <span class="bp">self</span><span class="o">.</span><span class="n">return_none</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_keys</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
        <span class="n">fn</span><span class="o">.</span><span class="n">profile</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">profile</span>
        <span class="k">return</span> <span class="n">fn</span>


<span class="k">def</span> <span class="nf">_pickle_FunctionMaker</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="n">kwargs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
        <span class="n">inputs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="p">,</span>
        <span class="n">outputs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">orig_outputs</span><span class="p">,</span>
        <span class="n">fgraph</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">fgraph</span><span class="p">,</span>
        <span class="n">mode</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">mode</span><span class="p">,</span>
        <span class="n">accept_inplace</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">accept_inplace</span><span class="p">,</span>
        <span class="n">function_builder</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">function_builder</span><span class="p">,</span>
        <span class="n">profile</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">profile</span><span class="p">,</span>
        <span class="n">on_unused_input</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">on_unused_input</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">_constructor_FunctionMaker</span><span class="p">,</span> <span class="p">(</span><span class="n">kwargs</span><span class="p">,))</span>


<span class="k">def</span> <span class="nf">_constructor_FunctionMaker</span><span class="p">(</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">theano</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">unpickle_function</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">theano</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">reoptimize_unpickled_function</span><span class="p">:</span>
            <span class="k">del</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;fgraph&#39;</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">FunctionMaker</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">None</span>

<span class="n">copyreg</span><span class="o">.</span><span class="n">pickle</span><span class="p">(</span><span class="n">FunctionMaker</span><span class="p">,</span> <span class="n">_pickle_FunctionMaker</span><span class="p">)</span>

<span class="n">__checkers</span> <span class="o">=</span> <span class="p">[]</span>


<span class="k">def</span> <span class="nf">check_equal</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">checker</span> <span class="ow">in</span> <span class="n">__checkers</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">checker</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="k">continue</span>
    <span class="k">return</span> <span class="n">x</span> <span class="o">==</span> <span class="n">y</span>


<span class="k">def</span> <span class="nf">register_checker</span><span class="p">(</span><span class="n">checker</span><span class="p">):</span>
    <span class="n">__checkers</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">checker</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">orig_function</span><span class="p">(</span><span class="n">inputs</span><span class="p">,</span> <span class="n">outputs</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">accept_inplace</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
                  <span class="n">name</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">profile</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">on_unused_input</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                  <span class="n">output_keys</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return a Function that will calculate the outputs from the inputs.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    inputs : list of `SymbolicInput` or `In` instances</span>
<span class="sd">    outputs : a SymbolicOutput or a list of `SymbolicOutput` or `Out` instances</span>
<span class="sd">        The return value of the returned function will match the format of this</span>
<span class="sd">        argument (either the value itself or a list of one or more return</span>
<span class="sd">        values).</span>
<span class="sd">    mode : descriptive string or Mode instance</span>
<span class="sd">        Default of None means to use `config.mode` (see below for descriptive</span>
<span class="sd">        string list).</span>
<span class="sd">    name : str</span>
<span class="sd">        An optional name for this fct. If used, the profile mode will print the</span>
<span class="sd">        time spent in this fct.</span>
<span class="sd">    accept_inplace : bool</span>
<span class="sd">        True iff the graph can contain inplace operations prior to the</span>
<span class="sd">        optimization phase (default is False).</span>
<span class="sd">    profile : None or ProfileStats instance</span>
<span class="sd">    on_unused_input : {&#39;raise&#39;, &#39;warn&#39;, &#39;ignore&#39;, None}</span>
<span class="sd">        What to do if a variable in the &#39;inputs&#39; list is not used in the graph.</span>
<span class="sd">    output_keys :</span>
<span class="sd">        If the outputs were provided to theano.function as a list, then</span>
<span class="sd">        output_keys is None. Otherwise, if outputs were provided as a dict,</span>
<span class="sd">        output_keys is the sorted list of keys from the outputs.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Currently, the library provides the following mode strings:</span>

<span class="sd">    - FAST_RUN (default) (optimize without too much time)</span>

<span class="sd">    - FAST_COMPILE (minimal optimization)</span>

<span class="sd">    - ProfileMode(deprecated): allow to print a profile mode with</span>
<span class="sd">      mode.print_summary</span>

<span class="sd">    - DebugMode: verify many internal conditions that are normally assumed</span>
<span class="sd">      (slow)</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Every element of the input list will be upgraded to an `In` instance if</span>
    <span class="c1"># necessary, using the rules implemented by the `convert_function_input`</span>
    <span class="c1"># function.</span>

    <span class="c1"># Similarly, every element of the output list will be upgraded to an `Out`</span>
    <span class="c1"># instance if necessary:</span>

    <span class="n">t1</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="n">mode</span> <span class="o">=</span> <span class="n">theano</span><span class="o">.</span><span class="n">compile</span><span class="o">.</span><span class="n">mode</span><span class="o">.</span><span class="n">get_mode</span><span class="p">(</span><span class="n">mode</span><span class="p">)</span>

    <span class="n">inputs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">convert_function_input</span><span class="p">,</span> <span class="n">inputs</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">outputs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">outputs</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
            <span class="n">outputs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">FunctionMaker</span><span class="o">.</span><span class="n">wrap_out</span><span class="p">,</span> <span class="n">outputs</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">outputs</span> <span class="o">=</span> <span class="n">FunctionMaker</span><span class="o">.</span><span class="n">wrap_out</span><span class="p">(</span><span class="n">outputs</span><span class="p">)</span>

    <span class="n">defaults</span> <span class="o">=</span> <span class="p">[</span><span class="nb">getattr</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="s1">&#39;value&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span> <span class="k">for</span> <span class="nb">input</span> <span class="ow">in</span> <span class="n">inputs</span><span class="p">]</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mode</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>  <span class="c1"># &quot;mode comparison&quot; semantics</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;We do not support the passing of multiple modes&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">Maker</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">mode</span><span class="p">,</span> <span class="s1">&#39;function_maker&#39;</span><span class="p">,</span> <span class="n">FunctionMaker</span><span class="p">)</span>
        <span class="n">fn</span> <span class="o">=</span> <span class="n">Maker</span><span class="p">(</span><span class="n">inputs</span><span class="p">,</span>
                   <span class="n">outputs</span><span class="p">,</span>
                   <span class="n">mode</span><span class="p">,</span>
                   <span class="n">accept_inplace</span><span class="o">=</span><span class="n">accept_inplace</span><span class="p">,</span>
                   <span class="n">profile</span><span class="o">=</span><span class="n">profile</span><span class="p">,</span>
                   <span class="n">on_unused_input</span><span class="o">=</span><span class="n">on_unused_input</span><span class="p">,</span>
                   <span class="n">output_keys</span><span class="o">=</span><span class="n">output_keys</span><span class="p">)</span><span class="o">.</span><span class="n">create</span><span class="p">(</span>
            <span class="n">defaults</span><span class="p">)</span>

    <span class="n">t2</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">profile</span><span class="p">:</span>
        <span class="n">profile</span><span class="o">.</span><span class="n">compile_time</span> <span class="o">+=</span> <span class="n">t2</span> <span class="o">-</span> <span class="n">t1</span>
        <span class="n">profile</span><span class="o">.</span><span class="n">nb_nodes</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">fn</span><span class="o">.</span><span class="n">maker</span><span class="o">.</span><span class="n">fgraph</span><span class="o">.</span><span class="n">apply_nodes</span><span class="p">)</span>

    <span class="n">fn</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
    <span class="n">fn</span><span class="o">.</span><span class="n">maker</span><span class="o">.</span><span class="n">fgraph</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
    <span class="k">return</span> <span class="n">fn</span>


<span class="k">def</span> <span class="nf">convert_function_input</span><span class="p">(</span><span class="nb">input</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Upgrade a input shortcut to an In instance.</span>

<span class="sd">    The rules for upgrading are as follows:</span>

<span class="sd">    - a `Variable` instance r will be upgraded like `In`(r)</span>

<span class="sd">    - a tuple (name, r) will be `In`(r, name=name)</span>

<span class="sd">    - a tuple (r, val) will be `In`(r, value=value, autoname=True)</span>

<span class="sd">    - a tuple ((r,up), val) will be</span>
<span class="sd">      `In`(r, value=value, update=up, autoname=True)</span>

<span class="sd">    - a tuple (name, r, val) will be `In`(r, name=name, value=value)</span>

<span class="sd">    - a tuple (name, (r,up), val) will be</span>
<span class="sd">      `In`(r, name=name, value=val, update=up, autoname=True)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="p">(</span><span class="n">SymbolicInput</span><span class="p">,</span> <span class="n">SymbolicInputKit</span><span class="p">)):</span>
        <span class="k">return</span> <span class="nb">input</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="n">gof</span><span class="o">.</span><span class="n">Constant</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;A Constant instance is not a legal function input&#39;</span><span class="p">,</span>
                        <span class="nb">input</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="n">gof</span><span class="o">.</span><span class="n">Variable</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">In</span><span class="p">(</span><span class="nb">input</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
        <span class="n">orig</span> <span class="o">=</span> <span class="nb">input</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">input</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Nonsensical input specification: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">input</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="nb">input</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">string_types</span><span class="p">):</span>
            <span class="n">name</span> <span class="o">=</span> <span class="nb">input</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="nb">input</span> <span class="o">=</span> <span class="nb">input</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">name</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="nb">input</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nb">input</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">!=</span> <span class="mi">2</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="nb">input</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Invalid input syntax: </span><span class="si">%s</span><span class="s2"> (check &quot;</span>
                                <span class="s2">&quot;documentation or use an In instance)&quot;</span> <span class="o">%</span> <span class="n">orig</span><span class="p">)</span>
            <span class="p">(</span><span class="n">variable</span><span class="p">,</span> <span class="n">update</span><span class="p">),</span> <span class="n">value</span> <span class="o">=</span> <span class="nb">input</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="nb">input</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">gof</span><span class="o">.</span><span class="n">Variable</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nb">input</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">variable</span><span class="p">,</span> <span class="n">update</span><span class="p">,</span> <span class="n">value</span> <span class="o">=</span> <span class="nb">input</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">None</span><span class="p">,</span> <span class="bp">None</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="nb">input</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="p">(</span><span class="n">variable</span><span class="p">,</span> <span class="n">value</span><span class="p">),</span> <span class="n">update</span> <span class="o">=</span> <span class="nb">input</span><span class="p">,</span> <span class="bp">None</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Invalid input syntax: </span><span class="si">%s</span><span class="s2"> (check &quot;</span>
                                <span class="s2">&quot;documentation or use an In instance)&quot;</span> <span class="o">%</span> <span class="n">orig</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="nb">input</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">(</span><span class="n">SymbolicInput</span><span class="p">,</span> <span class="n">SymbolicInputKit</span><span class="p">)):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nb">input</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span> <span class="nb">input</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="nb">input</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="nb">input</span><span class="p">,</span> <span class="n">value</span> <span class="o">=</span> <span class="nb">input</span>
                <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="nb">input</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
                <span class="nb">input</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span>
                <span class="k">return</span> <span class="nb">input</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;The input specification is not valid: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">input</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">variable</span><span class="p">,</span> <span class="n">gof</span><span class="o">.</span><span class="n">Variable</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Unknown input type: </span><span class="si">%s</span><span class="s2">, expected Variable &quot;</span>
                            <span class="s2">&quot;instance&quot;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">variable</span><span class="p">),</span> <span class="n">variable</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">update</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">update</span><span class="p">,</span> <span class="n">gof</span><span class="o">.</span><span class="n">Variable</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Unknown update type: </span><span class="si">%s</span><span class="s2">, expected Variable &quot;</span>
                            <span class="s2">&quot;instance&quot;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">update</span><span class="p">),</span> <span class="n">update</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">and</span>
                <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="p">(</span><span class="n">gof</span><span class="o">.</span><span class="n">Variable</span><span class="p">,</span> <span class="n">SymbolicInput</span><span class="p">))):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;The value for input </span><span class="si">%s</span><span class="s2"> should not be a Variable &quot;</span>
                            <span class="s2">&quot;or SymbolicInput instance (got: </span><span class="si">%s</span><span class="s2">)&quot;</span> <span class="o">%</span>
                            <span class="p">(</span><span class="n">variable</span><span class="p">,</span> <span class="n">value</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">In</span><span class="p">(</span><span class="n">variable</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="n">value</span><span class="p">,</span> <span class="n">update</span><span class="o">=</span><span class="n">update</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Unknown input type: </span><span class="si">%s</span><span class="s2">, expected Variable instance&quot;</span> <span class="o">%</span>
                        <span class="nb">type</span><span class="p">(</span><span class="nb">input</span><span class="p">),</span> <span class="nb">input</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">get_info_on_inputs</span><span class="p">(</span><span class="n">named_inputs</span><span class="p">,</span> <span class="n">n_unnamed_inputs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return a human-readable description of named and un-named inputs.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">n_named_inputs</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">named_inputs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_plural</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="s1">&#39;s&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="s1">&#39;&#39;</span>

    <span class="k">if</span> <span class="n">n_named_inputs</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">n_unnamed_inputs</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;The function is supposed to have no input.&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">n_unnamed_inputs</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;The function has a single input variable which has no &quot;</span>
                       <span class="s2">&quot;name, and thus cannot be assigned through a keyword&quot;</span>
                       <span class="s2">&quot; argument (use &#39;name=...&#39; in a Variable&#39;s &quot;</span>
                       <span class="s2">&quot;constructor to give it a name).&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Use plural.</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;The function has </span><span class="si">%s</span><span class="s2"> inputs, but none of them is named,&quot;</span>
                       <span class="s2">&quot; and thus they cannot be assigned through keyword &quot;</span>
                       <span class="s2">&quot;arguments (use &#39;name=...&#39; in a Variable&#39;s &quot;</span>
                       <span class="s2">&quot;constructor to give it a name).&quot;</span> <span class="o">%</span> <span class="n">n_unnamed_inputs</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">n_unnamed_inputs</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;The function has </span><span class="si">%s</span><span class="s2"> named input</span><span class="si">%s</span><span class="s2"> (</span><span class="si">%s</span><span class="s2">).&quot;</span> <span class="o">%</span>
                   <span class="p">(</span><span class="n">n_named_inputs</span><span class="p">,</span> <span class="n">get_plural</span><span class="p">(</span><span class="n">n_named_inputs</span><span class="p">),</span>
                    <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">named_inputs</span><span class="p">)))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;The function has </span><span class="si">%s</span><span class="s2"> named input</span><span class="si">%s</span><span class="s2"> (</span><span class="si">%s</span><span class="s2">), and </span><span class="si">%s</span><span class="s2"> unnamed &quot;</span>
                   <span class="s2">&quot;input</span><span class="si">%s</span><span class="s2"> which thus cannot be accessed through keyword &quot;</span>
                   <span class="s2">&quot;argument</span><span class="si">%s</span><span class="s2"> (use &#39;name=...&#39; in a variable&#39;s constructor &quot;</span>
                   <span class="s2">&quot;to give it a name).&quot;</span> <span class="o">%</span>
                   <span class="p">(</span><span class="n">n_named_inputs</span><span class="p">,</span> <span class="n">get_plural</span><span class="p">(</span><span class="n">n_named_inputs</span><span class="p">),</span>
                    <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">named_inputs</span><span class="p">),</span> <span class="n">n_unnamed_inputs</span><span class="p">,</span>
                    <span class="n">get_plural</span><span class="p">(</span><span class="n">n_unnamed_inputs</span><span class="p">),</span>
                    <span class="n">get_plural</span><span class="p">(</span><span class="n">n_unnamed_inputs</span><span class="p">)))</span>
    <span class="k">return</span> <span class="n">msg</span>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">Tetris  documentation</a> &raquo;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" >Module code</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &copy; Copyright 2016, Author.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.3.1.
    </div>
  </body>
</html>